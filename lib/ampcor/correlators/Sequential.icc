// -*- c++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// parasim
// (c) 1998-2020 all rights reserved

// code guard
#if !defined(ampcor_correlators_Sequential_icc)
#error this file contains implementation details for ampcor::correlators::Sequential
#else


// metamethods
// constructor
template <class slcT, class offsetsT>
ampcor::correlators::Sequential<slcT, offsetsT>::
Sequential(int rank,
           slc_const_reference ref, slc_const_reference sec, offsets_reference map,
           slc_shape_const_reference refShape, slc_shape_const_reference secShape,
           int refineFactor, int refineMargin,
           int zoomFactor) :
    // my rank
    _rank { rank },
    // access to the input rasters
    _ref { ref },
    _sec { sec },
    _map { map },
    // the shapes of tiles
    _refShape { refShape },
    _secShape { secShape },
    // the correlation refinement parameters
    _refineFactor { refineFactor },
    _refineMargin { refineMargin },
    _zoomFactor { zoomFactor }
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.setup");
    // show me
    channel
        << "[" << _rank << "]: "
        << "new Sequential worker:" << pyre::journal::newline
        // the reference tile shape
        << "  reference tiles:" << pyre::journal::newline
        << "     shape: {" << _refShape << "}" << pyre::journal::newline
        // the secondary tile coarse arena
        << "  secondary tiles:" << pyre::journal::newline
        << "     shape: {" << _secShape << "}" << pyre::journal::newline
        // flush
        << pyre::journal::endl(__HERE__);

    // all done
    return;
}


// execute the correlation plan
template <class slcT, class offsetsT>
void
ampcor::correlators::Sequential<slcT, offsetsT>::
adjust(offsets_layout_const_reference box)
{
    // make a channel
    pyre::journal::info_t channel("ampcor.sequential.adjust");

    // sign in
    channel
        << "[" << _rank << "]: "
        << "adjusting the offset map: origin: {"
        << box.origin() << "}, shape: {" << box.shape() << "}"
        << pyre::journal::endl(__HERE__);

    // we have a valid plan; perform an initial exploration
    coarseCorrelation(box);
    // refine the neighborhood of the coarse match and try again
    refinedCorrelation(box);

    // done
    channel
        << "[" << _rank << "]: "
        << "  done"
        << pyre::journal::endl(__HERE__);

    // all done
    return;
}

template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
coarseCorrelation(offsets_layout_const_reference box) -> void
{
    // make a channel
    pyre::journal::info_t channel("ampcor.sequential.adjust");

    // step 1: initial exploration of the correlation surface
    channel
        << "[" << _rank << "]: "
        << "  step 1: initial exploration of the correlation surface:"
        << pyre::journal::endl(__HERE__);

    // assemble and validate the work plan
    channel
        << "[" << _rank << "]: "
        << "    assembling and validating the work plan"
        << pyre::journal::endl(__HERE__);
    // build the plan
    plan_type plan = _assemblePlan(box, _refShape, _secShape);
    // if there are no valid pairs
    if (plan.size() == 0) {
        // make a channel
        pyre::journal::error_t error("ampcor.sequential.adjust");
        // complain
        error
            << "all specified correlation pairs were invalid!"
            << pyre::journal::endl(__HERE__);
        // just in case the user has specified that errors aren't fatal
        return;
    }

    // make a coarse arena for the amplitudes of the reference tiles
    channel
        << "[" << _rank << "]: "
        << "    creating coarse arenas for the amplitudes"
        << pyre::journal::endl(__HERE__);
    // the reference tile arena has a trivial origin
    slc_index_type refOrigin {};
    // make the arena
    auto refArena = _createAmplitudeArena("coarse_ref.dat", plan.size(), _refShape, refOrigin);

    // the secondary tile arena has a non-trivial origin
    slc_index_type secOrigin = refOrigin - (_secShape - _refShape)/2;
    // make the arena
    auto secArena = _createAmplitudeArena("coarse_sec.dat", plan.size(), _secShape, secOrigin);

    // detect and transfer the reference tile tiles to the coarse arena
    channel
        << "[" << _rank << "]: "
        << "    detecting and transferring"
        << pyre::journal::endl(__HERE__);
    // move the data
    _detect(plan, refArena, secArena);

    // compute the correlation surface
    auto gamma = _gamma("coarse", refArena, secArena);

    // find its maxima
    channel
        << "[" << _rank << "]: "
        << "    locating the correlation surface maxima and recording the offsets"
        << pyre::journal::endl(__HERE__);
    _maxcor(gamma, 1);

    // all done
    return;
}


// narrow the search down to a smaller neighborhood of the best matching pairs, refine using
// DFTs, and then zoom in to get subpixel estimates
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
refinedCorrelation(offsets_layout_const_reference box) -> void
{
    // make a channel
    pyre::journal::info_t channel("ampcor.sequential.adjust");

    // check the parameters
    // if we have an invalid refinement factor
    if (_refineFactor < 2) {
        // get a channel
        pyre::journal::warning_t warning("ampcor.sequential.refined");
        // generate a report
        warning
            << "while refining the search:"
            << pyre::journal::newline
            << "refinement factor: " << _refineFactor
            << pyre::journal::newline
            << "unable to refine; refinement factor must be 2 or greater"
            << pyre::journal::endl(__HERE__);
        // and bail
        return;
    }
    // if we have an invalid refinement margin
    if (_refineMargin < 1) {
        // get a channel
        pyre::journal::warning_t warning("ampcor.sequential.refined");
        // generate a report
        warning
            << "while refining the search:"
            << pyre::journal::newline
            << "refinement margin: " << _refineMargin
            << pyre::journal::newline
            << "unable to refine; refinement margin must be 1 or greater"
            << pyre::journal::endl(__HERE__);
        // and bail
        return;
    }

    // step 2: refining the search neighborhoods and trying again
    channel
        << "[" << _rank << "]: "
        << "  step 2: refining the search:"
        << pyre::journal::endl(__HERE__);

    // a useful index
    slc_shape_type one { 1, 1 };

    // form the shape of the refined neighborhood in the reference raster
    auto refRefinedShape = _refShape / _refineFactor;
    // form the shape of the refined neighborhood in the secondary raster
    auto secRefinedShape = refRefinedShape + 2 * _refineMargin * one;

    // assemble and validate the work plan
    channel
        << "[" << _rank << "]: "
        << "    assembling and validating the work plan"
        << pyre::journal::endl(__HERE__);
    // build the plan
    plan_type plan = _assemblePlan(box, refRefinedShape, secRefinedShape);
    // if there are no valid pairs
    if (plan.size() == 0) {
        // make a channel
        pyre::journal::error_t error("ampcor.sequential.adjust");
        // complain
        error
            << "all specified correlation pairs were invalid!"
            << pyre::journal::endl(__HERE__);
        // just in case the user has specified that errors aren't fatal
        return;
    }

    // build a staging area for the complex pixels so we can deramp and refine them
    channel
        << "[" << _rank << "]: "
        << "    allocating temporary storage for the refined tiles"
        << pyre::journal::endl(__HERE__);

    // for the reference tiles, use a trivial origin
    slc_index_type refRefinedOrigin { 0, 0 };
    // make the arena
    auto refRefinedComplex = _createComplexArena("complex_ref.dat",
                                                 plan.size(),
                                                 refRefinedOrigin, refRefinedShape);

    // for the secondary tiles, shift the origin by _refineMargin
    slc_index_type secRefinedOrigin { -_refineMargin, -_refineMargin };
    auto secRefinedComplex = _createComplexArena("complex_sec.dat",
                                                 plan.size(),
                                                 secRefinedOrigin, secRefinedShape);

    // prime the complex arenas
    channel
        << "[" << _rank << "]: "
        << "    transferring tiles from the input rasters"
        << pyre::journal::endl(__HERE__);
    // move data from the rasters to the complex arenas
    _primeComplexArenas(plan, refRefinedComplex, secRefinedComplex);

    // deramp
    channel
        << "[" << _rank << "]: "
        << "    deramping"
        << pyre::journal::endl(__HERE__);
    // the reference arena
    channel
        << "[" << _rank << "]: "
        << "      the reference arena"
        << pyre::journal::endl(__HERE__);
    _deramp(refRefinedComplex);
    // the secondary arena
    channel
        << "[" << _rank << "]: "
        << "      the secondary arena"
        << pyre::journal::endl(__HERE__);
    _deramp(secRefinedComplex);

    // refine
    channel
        << "[" << _rank << "]: "
        << "    refining"
        << pyre::journal::endl(__HERE__);
    // the reference arena
    channel
        << "[" << _rank << "]: "
        << "      the reference arena"
        << pyre::journal::endl(__HERE__);
    _refine(refRefinedComplex, _refineFactor);
    // the secondary arena
    channel
        << "[" << _rank << "]: "
        << "      the secondary arena"
        << pyre::journal::endl(__HERE__);
    _refine(secRefinedComplex, _refineFactor);

    // detect the newly refined arenas
    channel
        << "[" << _rank << "]: "
        << "    detecting"
        << pyre::journal::endl(__HERE__);
    // the reference arena
    channel
        << "[" << _rank << "]: "
        << "      the reference arena"
        << pyre::journal::endl(__HERE__);
    auto refArena = _detectComplexArena("refined_ref.dat", refRefinedComplex);
    // show me
    channel
        << "[" << _rank << "]: "
        << "        origin (" << refArena.layout().origin()
        << ")+(" << refArena.layout().shape() << ")"
        << pyre::journal::endl(__HERE__);

    // the secondary arena
    channel
        << "[" << _rank << "]: "
        << "      the secondary arena"
        << pyre::journal::endl(__HERE__);
    auto secArena = _detectComplexArena("refined_sec.dat", secRefinedComplex);
    // show me
    channel
        << "[" << _rank << "]: "
        << "        origin (" << secArena.layout().origin()
        << ")+(" << secArena.layout().shape() << ")"
        << pyre::journal::endl(__HERE__);

    // compute the refined correlation matrix
    auto gamma = _gamma("refined", refArena, secArena);

    // if we are not zooming into the correlation surface
    if (_zoomFactor < 2) {
        // find its maxima
        channel
            << "[" << _rank << "]: "
            << "    locating the correlation surface maxima and recording the offsets"
            << pyre::journal::endl(__HERE__);
        // compute the maximum of the new correlation surface
        _maxcor(gamma, _refineFactor);
        // and we are done
        return;
    }

    // zoom
    channel
        << "[" << _rank << "]: "
        << "    zooming the correlation surface by a factor of " << _zoomFactor
        << pyre::journal::endl(__HERE__);
    // refine the correlation surface
    auto gammaZoomed = _zoom(gamma);
    // find its maxima
    channel
        << "[" << _rank << "]: "
        << "    locating the correlation surface maxima and recording the offsets"
        << pyre::journal::endl(__HERE__);
    // compute the maximum and store
    _maxcor(gammaZoomed, _refineFactor * _zoomFactor);

    // all done
    return;
}


// implementation details
// go through the sequence of steps necessary to compute the correlation surface given a pair
// of arenas with detected tiles
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_gamma(string_type tag, arena_reference refArena, arena_reference secArena)
    -> const_arena_type
{
    // make a channel
    pyre::journal::info_t channel("ampcor.sequential.gamma");

    // the reference tiles
    channel
        << "[" << _rank << "]: "
        << "    prepping the reference tiles:"
        << pyre::journal::endl(__HERE__);
    // adjust the reference tiles to zero mean and compute their variance
    channel
        << "[" << _rank << "]: "
        << "      adjusting the amplitudes to zero mean and computing statistics"
        << pyre::journal::endl(__HERE__);
    auto refVariances = _referenceStatistics(refArena);

    // next, the secondary tiles
    channel
        << "[" << _rank << "]: "
        << "    prepping the secondary tiles:"
        << pyre::journal::endl(__HERE__);

    // build sum area tables so we can do the same to the sliding window in the secondary tiles
    channel
        << "[" << _rank << "]: "
        << "      building sum area tables"
        << pyre::journal::endl(__HERE__);
    auto secSATs = _secondarySumAreaTables(tag, secArena);

    // use the sum area tables to compute mean amplitude for all possible window placements
    channel
        << "[" << _rank << "]: "
        << "      computing statistics"
        << pyre::journal::endl(__HERE__);
    auto secMeans = _secondaryStatistics(tag,
                                         refArena.layout(), secArena.layout(),
                                         secSATs);

    // generate the correlation surface
    // slide {ref} sized chips around {sec} to compute the correlation hyper surface
    channel
        << "[" << _rank << "]: "
        << "    computing the correlation surface"
        << pyre::journal::endl(__HERE__);
    auto gamma = _correlate(tag, refArena, refVariances, secArena, secMeans);
    // show me
    channel
        << "[" << _rank << "]: "
        << "       " << tag << " gamma: origin (" << gamma.layout().origin() << ")+("
        << gamma.layout().shape() << ")"
        << pyre::journal::endl(__HERE__);

    // all done
    return gamma;
}


// plan assembly: pull out of {_map} the portion of the tile pairings that belong to me,
// discard the ones that don't fit within their respective inputs, and form the actual tile
// shapes
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_assemblePlan(offsets_layout_const_reference box,
              slc_shape_const_reference refShape, slc_shape_const_reference secShape)
    -> plan_type
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.plan");

    // make a plan
    plan_type plan;

    // extent of the input rasters
    // the lower bound for an index into the reference raster is its origin
    auto refMinIndex = _ref.layout().origin();
    // similarly for the secondary raster
    auto secMinIndex = _sec.layout().origin();
    // form the strict upper bound of indices into the reference index
    auto refMaxIndex = refMinIndex + _ref.layout().shape();
    // ditto for the secondary raster
    auto secMaxIndex = secMinIndex + _sec.layout().shape();

    // shifts to apply to the tile centers to form the origins of tiles
    auto refShift = refShape / 2;
    auto secShift = secShape / 2;

    // go through my portion of the pairings
    for (auto pairIdx : _map.layout().box(box.origin(), box.shape())) {
        // get the pair
        auto pair = _map[pairIdx];
        // convert the center of the {ref} tile into an index
        slc_index_type refCenter {
            static_cast<int>(pair.ref.first), static_cast<int>(pair.ref.second)
        };

        // form the origin of the reference tile
        auto refOrigin = refCenter - refShift;
        // if the reference origin is out of bounds
        if (refOrigin < refMinIndex) {
            // tell me
            channel
                << "[" << _rank << "]: "
                << "      pair (" << pairIdx << ") is invalid:"
                << pyre::journal::newline
                << "        origin@(" << refOrigin << ") < ref origin@(" << refMinIndex << ")"
                << pyre::journal::newline;
            // skip this pairing; it is invalid
            continue;
        }
        // if the extent spills out of the reference raster
        if (refOrigin + refShape > refMaxIndex) {
            // tell me
            channel
                << "[" << _rank << "]: "
                << "      pair (" << pairIdx << ") is invalid:"
                << pyre::journal::newline
                << "        origin@(" << refOrigin << ") + shape@(" << refShape
                << ") > ref shape@(" << refMaxIndex << ")"
                << pyre::journal::newline;
            // skip this pairing; it is invalid
            continue;
        }

        // compute the center of the {sec} tile
        auto secCenter = refCenter + slc_index_type(static_cast<int>(pair.shift.first),
                                                    static_cast<int>(pair.shift.second));
        // form the origin of the secondary tile
        auto secOrigin = secCenter - secShift;
        // if it's out of bounds
        if (secOrigin < secMinIndex) {
            // tell me
            channel
                << "[" << _rank << "]: "
                << "      pair (" << pairIdx << ") is invalid:"
                << pyre::journal::newline
                << "        origin@(" << secOrigin << ") < sec origin@(" << secMinIndex << ")"
                << pyre::journal::newline;
            // skip this pairing; it is invalid
            continue;
        }
        // if the extent spills out of the secondary raster
        if (secOrigin + secShape > secMaxIndex) {
            // tell me
            channel
                << "[" << _rank << "]: "
                << "      pair (" << pairIdx << ") is invalid:"
                << pyre::journal::newline
                << "        origin@(" << secOrigin << ") + shape@(" << secShape
                << ") > sec shape@(" << secMaxIndex << ")"
                << pyre::journal::newline;
            // skip this pairing; it is invalid
            continue;
        }

        // we have a valid pair; turn it into a plan record
        plan.push_back({pairIdx, refOrigin, secOrigin});
    }

    // tell me
    channel
        << "[" << _rank << "]: "
        << "      " << plan.size() << "/" << box.cells() << " valid tile pairs"
        << pyre::journal::endl(__HERE__);

    // all done
    return plan;
}


// build a real arena as an intermediate data product
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_createAmplitudeArena(string_type name, int pairs,
                      slc_shape_const_reference tileShape,
                      slc_index_const_reference tileOrigin)
    -> arena_type
{
    // make a channel
    pyre::journal::info_t channel("ampcor.sequential.arena");

    // turn the number of pairs into a shape
    typename arena_type::spec_type::id_layout_type::shape_type pairsShape { pairs };
    // combine with the tile shape to form the arena layout
    auto arenaShape = pairsShape * tileShape;

    // pair numbering starts at zero
    typename arena_type::spec_type::id_layout_type::index_type pairsOrigin { 0 };
    // combine with the tile origin to form the arena origin
    auto arenaOrigin = pairsOrigin * tileOrigin;

    // convert all this to a layout
    typename arena_type::layout_type arenaLayout { arenaShape, arenaOrigin };

    // show me
    channel
        << "[" << _rank << "]: "
        << "      creating '" << name << "':"
        << " origin=(" << arenaOrigin << "), shape=(" << arenaShape << ")"
        << pyre::journal::endl(__HERE__);

    // create the product and return it
    return arena_type(arenaLayout, name, arenaLayout.cells());
}


// transfer tiles from the input rasters into corresponding arenas, and compute their magnitude
// in flight
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_detect(plan_const_reference plan, arena_reference refArena, arena_reference secArena) -> void
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.adjust");

    // detecting means
    auto detect = [](slc_pixel_type pixel) -> slc_value_type {
        // computing the amplitude of the complex pixel
        return std::abs(pixel);
    };

    // go through the plan
    for (auto pid = 0; pid < plan.size(); ++pid) {
        // get the origins of the tiles in their respective rasters
        const auto & [_, refOrigin, secOrigin] = plan[pid];
        // show me
        channel
            << "[" << _rank << "]: "
            << "      detecting ref(" << refOrigin << ") and sec(" << secOrigin <<  ")"
            << pyre::journal::endl(__HERE__);

        // we traverse one tile at a time
        typename arena_type::spec_type::id_layout_type::index_type pairShape { 1 };
        // the pairing id determines the shift from the arena origin to our tile
        arena_index_type pairShift { pid, 0, 0 };

        // specify the source tile in the reference raster
        auto refTile = _ref.box(refOrigin, _refShape);
        // specify the destination tile
        auto refArenaTile = refArena.box(refArena.layout().origin() + pairShift,
                                         pairShape * _refShape);
        // detect
        std::transform(refTile.begin(), refTile.end(), refArenaTile.begin(), detect);

        // specify the source tile in the secondary raster
        auto secTile = _sec.box(secOrigin, _secShape);
        // specify the destination tile
        auto secArenaTile = secArena.box(secArena.layout().origin() + pairShift,
                                         pairShape * _secShape);
        // detect
        std::transform(secTile.begin(), secTile.end(), secArenaTile.begin(), detect);
    }

    // all done
    return;
}


// reduce the tiles in {arena} to zero mean and compute their variances
// invoked only for reference tiles; the mean value of secondary tiles is a bit more
// complicated since it involves all possible placements of reference chips within their bounds
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_referenceStatistics(arena_reference arena) -> vector_pointer
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.ref.stats");

    // the shape of the arena contains the shape of its tiles
    const auto & shape = arena.layout().shape();
    // the origin of the arena contains the origin of its tiles
    const auto & origin = arena.layout().origin();

    // the number of pairs in the plan
    auto pairs = shape[0];

    // allocate storage for the variances
    auto variance = new vector_type(pairs);

    // go through each tile
    for (auto tid = 0; tid < pairs; ++tid) {
        // isolate the tile
        channel << "tile " << tid << pyre::journal::newline;
        // the origin of the tile
        arena_index_type tileOrigin { tid, origin[1], origin[2] };
        // the shape of the tile
        arena_shape_type tileShape { 1, shape[1], shape[2] };
        // make the tile
        auto tile = arena.box(tileOrigin, tileShape);

        // compute the sum of its elements
        auto sum = std::accumulate(tile.begin(), tile.end(), 0.0);
        channel << "  sum: " << sum << pyre::journal::newline;
        // compute the mean
        auto mean = sum / tile.layout().cells();
        channel << "  mean: " << mean << pyre::journal::newline;

        // subtract it from all elements and store
        std::transform(tile.begin(), tile.end(), tile.begin(),
                       [mean](arena_value_type in) -> arena_value_type {
                           return in - mean;
                       });

        // the accumulator of square
        auto sumsq = [](arena_value_type partial, arena_value_type in) {
            // easy enough
            return partial + in*in;
        };
        // compute the sum of the squares of all new elements
        auto var2 = std::accumulate(tile.begin(), tile.end(), 0.0, sumsq);
        channel << "  sum of squares: " << var2 << pyre::journal::newline;
        // compute the variance
        auto var = std::sqrt(var2);
        channel << "  variance: " << var << pyre::journal::newline;

        (*variance)[tid] = var;
    }

    // flush
    channel << pyre::journal::endl(__HERE__);

    // return the variances
    return vector_pointer(variance);
}


// build an arena of SATs for all secondary tiles
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_secondarySumAreaTables(string_type tag, const_arena_const_reference arena) -> const_arena_type
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.sat");

    // build the name of the product
    auto satName = tag + "_sat.dat";

    // get the arena layout
    const auto & arenaLayout = arena.layout();
    // the shape of the arena contains the shape of its tiles
    const auto & arenaShape = arenaLayout.shape();
    // the origin of the arena contains the origin of its tiles
    const auto & arenaOrigin = arenaLayout.origin();

    // the SAT has a border of zeroes as the leftmost column and topmost row
    // so the origin is up and to the left relative to the arena tiles
    arena_index_type satOrigin { arenaOrigin[0], arenaOrigin[1]-1, arenaOrigin[2]-1 };
    // and the shape is one longer within each tile
    arena_shape_type satShape { arenaShape[0], arenaShape[1]+1, arenaShape[2]+1 };
    // put them together to form the layout
    arena_layout_type satLayout { satShape, satOrigin };
    // and the spec
    arena_spec satSpec { satLayout };
    // and make the SAT; memory mapped grids are zero initialized automatically, so don't
    // forget to initialize the left column and top row if the grid storage strategy changes
    arena_type sat(satSpec, satName, satLayout.cells());

    // index shifts
    arena_index_type up { 0, -1, 0 };
    arena_index_type left { 0, 0, -1 };

    // visit the interior of the SAT
    for (auto idx : arenaLayout) {
        // this is the general form
        sat[idx] = arena[idx] + sat[idx+up] + sat[idx+left] - sat[idx+up+left];
        // show me
        channel
            << "sat[" << idx << "]"
            << pyre::journal::newline
            // the accesses
            << "    = "
            << "arena[" << idx << "]"
            << " + sat[" << idx+up << "]"
            << " + sat[" << idx+left << "]"
            << " - sat[" << idx+up+left << "]"
            << pyre::journal::newline
            // the values
            << "    = "
            << arena[idx]
            << " + " << sat[idx+up]
            << " + " << sat[idx+left]
            << " - " << sat[idx+up+left]
            << pyre::journal::newline
            // the answer
            << "    = " << sat[idx]
            << pyre::journal::newline;
    }
    // flush
    channel << pyre::journal::endl(__HERE__);

    // all done; reopen the product in read-only mode and hand it off
    return const_arena_type(satSpec, satName);;
}


// construct an arena that contains the average value of the elements of all {ref} sized chips
// placed with the {sec} tiles
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_secondaryStatistics(string_type tag,
                     arena_layout_const_reference refLayout,
                     arena_layout_const_reference secLayout,
                     const_arena_const_reference sat) -> const_arena_type
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.sec.stats");

    // build the name of the product
    auto meanName = tag + "_mean.dat";

    // get the shape of the reference arena
    auto refShape = refLayout.shape();
    // and the shape of the secondary arena
    auto secShape = secLayout.shape();
    // we also need the origin of the secondary arena
    auto secOrigin = secLayout.origin();

    // the number of pairs in the plan
    auto pairs = secLayout.shape()[0];

    // build the shape of the arena of mean values
    arena_shape_type meanShape { pairs, secShape[1]-refShape[1]+1, secShape[2]-refShape[2]+1 };
    // use it to make a layout
    arena_layout_type meanLayout { meanShape, secOrigin };
    // and with it a product spec
    arena_spec meanSpec { meanLayout };

    // show me
    channel
        << "arena of mean values: "
        << pyre::journal::newline
        // the origin
        << "  origin: (" << secOrigin << ")"
        << pyre::journal::newline
        // the shape
        << "  shape: (" << meanShape << ")"
        << ", " << meanSpec.cells() << " cells (" << meanSpec.bytes() << " bytes)"
        << pyre::journal::newline;

    // create the product
    arena_type mean { meanSpec, meanName, meanSpec.cells() };

    // ask the reference tile for its number of cells; don't forget that {refShape} knows how
    // many tiles are in the arena, so that has to be divided away
    auto refCells = refShape.cells() / pairs;
    // project the shape of the reference tile along each tile axis
    arena_index_type shapeS { 0, refShape[1], 0 };
    arena_index_type shapeE { 0, 0, refShape[2] };
    // useful shifts
    arena_index_type dNW { 0, -1, -1 };
    auto dNE = dNW + shapeE;
    auto dSW = dNW + shapeS;
    auto dSE = dNW + shapeE + shapeS;

    // go through all placements
    for (auto idx : meanLayout) {
        // compute the sum of the elements of this placement
        auto sum = sat[idx+dSE] - sat[idx+dSW] - sat[idx+dNE] + sat[idx+dNW];
        // form the mean and store it
        mean[idx] = sum / refCells;
        // show me
        channel
            << "mean[" << idx << "] = " << sum << " / " << refCells
            << " = " << mean[idx]
            << pyre::journal::newline;
    }

    // flush
    channel << pyre::journal::endl(__HERE__);

    // all done: reopen the product as read-only and return it
    return const_arena_type(meanSpec, meanName);
}


// compute the correlation surface
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_correlate(string_type tag,
           const_arena_const_reference ref, vector_pointer refStats,
           const_arena_const_reference sec, const_arena_const_reference secStats)
    -> const_arena_type
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.gamma");

    // constants
    // prime the initializer
    const arena_value_type zero = 0;
    // a small number
    const auto epsilon = std::numeric_limits<arena_value_type>::epsilon();

    // get the shape of the reference arena
    auto refShape = ref.layout().shape();
    // and its origin
    auto refOrigin = ref.layout().origin();

    // build the name of the product
    auto gammaName = tag + "_gamma.dat";
    // the correlation surface looks just like the arena with the means of all the tile
    // placements
    arena_spec gammaSpec { secStats.layout() } ;

    // create the product
    arena_type gamma { gammaSpec, gammaName, gammaSpec.cells() };

    // the shape of the reference tiles fixes the correlation region for both reference and
    // secondary tiles
    arena_shape_type shape { 1, refShape[1], refShape[2] };

    // go through all indices covered by the {gamma} layout
    for (auto idx : gamma.layout()) {
        // extract the pair id
        auto pid = idx[0];

        // build the {ref} tile origin
        arena_index_type refTileOrigin { pid, refOrigin[1], refOrigin[2] };
        // combine with the fixed shape to form the reference tile
        auto refTile = ref.box(refTileOrigin, shape);

        // the secondary tile is the same shape but its origin is wherever the current placement is
        auto secTile = sec.box(idx, shape);

        // get the precomputed mean value for this placement
        auto mean = secStats[idx];

        // initialize the numerator
        auto num = zero;
        // and the sum of the squares of the secondary elements
        auto var2 = zero;

        // compute the correlation numerator and the square of the variance of the secondary
        // chip
        for (auto [r,s] = std::make_pair(refTile.begin(), secTile.begin());
             r != refTile.end();
             ++r, ++s ) {
            // remove the mean from the secondary value
            auto adj = *s - mean;
            // accumulate into the numerator
            num += *r * adj;
            // and into the variance
            var2 += adj * adj;
        }

        // unpack the reference variance
        auto revVar = (*refStats)[pid];
        // compute the secondary variance
        auto secVar = std::sqrt(var2);
        // check whether the numerator is viable
        if (std::abs(num) > epsilon) {
            // compute and save
            gamma[idx] = num / revVar / secVar;
        } else {
            // otherwise, store a zeor
            gamma[idx] = zero;
        }

        // show me
        channel
            << "ref: origin: (" << refOrigin << "), shape: (" << shape << ")"
            << pyre::journal::newline
            << "sec: origin: (" << idx
            << "), shape: (" << shape << "), "
            << "mean[" << idx << "] = " << mean
            << pyre::journal::newline
            << "gamma[" << idx << "]"
            << "  = ref[" << refTileOrigin << "] * sec[" << idx << "]"
            << pyre::journal::newline
            << "  = " << num << " / " << revVar << " / " << secVar
            << pyre::journal::newline
            << "  = " << gamma[idx]
            << pyre::journal::newline;
    }

    // flush
    channel << pyre::journal::endl(__HERE__);

    // all done: reopen the product as read-only and return it
    return const_arena_type(gammaSpec, gammaName);
}


// compute and store the locations of the maxima of the correlation surface
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_maxcor(const_arena_const_reference gamma, slc_value_type zoomFactor) -> void
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.maxcor");

    // get the layout of the correlation matrix
    const auto & corLayout = gamma.layout();
    // get the shape of the correlation matrix
    const auto & corShape = corLayout.shape();
    // and its origin
    const auto & corOrigin = corLayout.origin();

    // the number of pairs is buried in gamma
    auto pairs = corShape[0];

    // go through the plan
    for (auto pid = 0; pid < pairs; ++pid) {
        // narrow {gamma} to a tile corresponding to this pairing only
        // the shape
        arena_shape_type shape  { 1, corShape[1], corShape[2] };
        // the origin
        arena_index_type origin { pid, corOrigin[1], corOrigin[2] };
        // make the tile
        auto tile = corLayout.box(origin, shape);

        // initialize the correlation target
        float corMax = 0;
        // and a shift
        slc_index_type delta { 0,0 };

        // go through the tile
        for (auto idx : tile) {
            // get the correlation value
            auto cor = gamma[idx];
            // if it is greater than what we have seen before
            if (cor > corMax) {
                // save the new value
                corMax = cor;
                // form the associated shift
                delta = slc_index_type(idx[1], idx[2]);
            }
        }

        // get the corresponding record from the output product, in write enabled mode
        auto & rec = _map[pid];
        // record the new value
        rec.gamma = corMax;
        // update the shift
        rec.shift.first += delta[0] / zoomFactor;
        rec.shift.second += delta[1] / zoomFactor;
        // mark it as a good one
        rec.confidence = 1;
        // show me
        channel
            << pid << ": "
            << "gamma: max@(" << delta << "): "
            << "(" << rec.ref.first << "," << rec.ref.second << ") --> ("
            << rec.ref.first + rec.shift.first << "," << rec.ref.second + rec.shift.second << "), "
            << "gamma: " << rec.gamma
            << pyre::journal::newline;
    }

    // flush
    channel << pyre::journal::endl(__HERE__);

    // all done
    return;
}


// allocate complex arenas; currently memory mapped, which implies zero initialization
// automatically
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_createComplexArena(string_type name, int pairs,
                    slc_index_const_reference tileOrigin, slc_shape_const_reference tileShape)
    -> carena_type
{
    // make a channel
    pyre::journal::info_t channel("ampcor.sequential.refine");

    // make a zero to be used to assemble the arena origin
    typename carena_type::spec_type::id_layout_type::index_type pairsOrigin { 0 };
    // after refinement, the tile origin will be
    auto refinedOrigin = _refineFactor * tileOrigin;
    // combine with the pair origin to form the arena origin
    auto carenaOrigin = pairsOrigin * refinedOrigin;

    // turn the number of pairs into a shape
    typename carena_type::spec_type::id_layout_type::shape_type pairsShape { pairs };
    // after refinement, the tile shape will be
    auto refinedShape = _refineFactor * tileShape;
    // combine with the tile shape to form the tile layout
    auto carenaShape = pairsShape * refinedShape;

    // no need for a fancy origin until after detection, so just make a layout
    typename carena_type::layout_type carenaLayout { carenaShape, carenaOrigin };

    // show me
    channel
        << "[" << _rank << "]: "
        << "      creating '" << name << "':"
        << " origin=(" << carenaLayout.origin() << "), shape=(" << carenaLayout.shape() << ")"
        << pyre::journal::endl(__HERE__);

    // create the product and return it
    return carena_type(carenaLayout, name, carenaLayout.cells());
}


// move complex tiles from the input rasters to appropriately shaped temporary storage so we
// can deramp and refine them
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_primeComplexArenas(plan_const_reference plan,
                    carena_reference refArena, carena_reference secArena)
    -> void
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.refine");

    // get the arena origins
    auto refArenaOrigin = refArena.layout().origin();
    auto secArenaOrigin = secArena.layout().origin();
    // and he arena shapes
    auto refArenaShape = refArena.layout().shape();
    auto secArenaShape = secArena.layout().shape();
    // get the shapes of the reference tiles from the arenas
    slc_shape_type refRefinedShape { refArenaShape[1], refArenaShape[2] };
    slc_shape_type secRefinedShape { secArenaShape[1], secArenaShape[2] };
    // the source tiles shapes are smaller than this by the {_refineFactor}
    auto refShape = refRefinedShape / _refineFactor;
    auto secShape = secRefinedShape / _refineFactor;

    // go through the plan
    for (auto pid=0; pid < plan.size(); ++pid) {
        // get the origins of the tiles in their respective rasters
        const auto & [pdx, refOrigin, secOrigin] = plan[pid];

        // to move the data, we must form the destination boxes in the complex arenas
        // make a shift from the arena origin to the start of the current pairing
        carena_index_type pair { pid, 0, 0 };
        // form the origin of the {ref} tile
        auto refTileOrigin = refArenaOrigin + pair;
        // and the origin of the {sec} tile
        auto secTileOrigin = secArenaOrigin + pair;

        // we must also form shapes that is as big as the origin tiles for one pairing
        // we will take the cartesian product of a pair selector shape
        typename carena_spec::id_layout_type::shape_type one { 1 };
        // with the reference tile shape
        auto refTileShape = one * refShape;
        // and the secondary tile shape
        auto secTileShape = one * secShape;

        // we copy from a tiles in the input rasters
        auto refSrcTile = _ref.box(refOrigin, refShape);
        auto secSrcTile = _sec.box(secOrigin, secShape);
        // to tiles in the corresponding arenas
        auto refDestTile = refArena.box(refTileOrigin, refTileShape);
        auto secDestTile = secArena.box(secTileOrigin, secTileShape);

        // tell me
        channel
            << "pid: #" << pid << ", pairing (" << pdx << "):"
            << pyre::journal::newline;

        // transfer the data from the reference raster
        std::copy(refSrcTile.begin(), refSrcTile.end(), refDestTile.begin());
        // tell me
        channel
            << "  ref:"
            << pyre::journal::newline
            // the source
            << "    from: (" << refOrigin << ")+(" << refShape << "), "
            << refSrcTile.layout().cells() << " cells"
            << pyre::journal::newline
            // the destination
            << "      to: (" << refTileOrigin << ")+(" << refTileShape << "), "
            << refDestTile.layout().cells() << " cells"
            << pyre::journal::newline;

        // transfer the data from the secondary raster
        std::copy(secSrcTile.begin(), secSrcTile.end(), secDestTile.begin());
        // tell me
        channel
            << "  sec:"
            << pyre::journal::newline
            // the source
            << "    from: (" << secOrigin << ")+(" << secShape << "), "
            << secSrcTile.layout().cells() << " cells"
            << pyre::journal::newline
            // the destination
            << "      to: (" << secTileOrigin << ")+(" << secTileShape << "), "
            << secDestTile.layout().cells() << " cells"
            << pyre::journal::newline;
    }

    // flush
    channel << pyre::journal::endl(__HERE__);
    // all done
    return;
}


// deramp
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_deramp(carena_reference arena) -> void
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.refine");

    // we do floating point arithmetic...
    auto eps = std::numeric_limits<float>::epsilon();

    // get the layout of the arena
    auto arenaLayout = arena.layout();
    // its origin
    auto arenaOrigin = arenaLayout.origin();
    // and its shape
    auto arenaShape = arenaLayout.shape();

    // get the number of tiles in the arena
    auto tiles = arenaShape[0];

    // make a shift that can be used to move the arena origin to the beginning of a tile
    carena_index_type ofTile { 1, 0 , 0};
    // make a shape that narrows iterations to one tile at native resolution
    carena_shape_type tileShape { 1, arenaShape[1]/_refineFactor, arenaShape[2]/_refineFactor };

    // in order to accumulate the phase when scanning tiles horizontally, we must narrow the
    // tile shape by one column
    carena_shape_type colRake { 0, 0, -1 };
    // since we access the cell to the right of the current one
    carena_index_type colNext { 0, 0, 1 };

    // in order to accumulate the phase when scanning tiles vertically, we must narrow the tile
    // shape by one row
    carena_shape_type rowRake { 0, -1, 0 };
    // since we access the cell below the current one
    carena_index_type rowNext { 0, 1, 0 };

    // show me
    channel
        << pyre::journal::newline
        << "arena shape: (" << arenaShape << ")" << pyre::journal::newline
        << " tile shape: (" << tileShape << ")" << pyre::journal::newline;

    // the horizontal phase accumulator
    auto phaseHorzAccum =
        [&arena, &colNext](carena_value_type sum, carena_index_type idx) -> carena_value_type {
            // multiply this cell with the complex conjugate of its neighbor to the right
            auto value = arena[idx]*std::conj(arena[idx+colNext]);
            // accumulate and return
            return sum + value;
        };
    // the vertical phase accumulator
    auto phaseVertAccum =
        [&arena, &rowNext](carena_value_type sum, carena_index_type idx) -> carena_value_type {
            // multiply this cell with the complex conjugate of its neighbor below
            auto value = arena[idx]*std::conj(arena[idx+rowNext]);
            // accumulate and return
            return sum + value;
        };
    // also, we need this in order to prime the accumulator correctly
    carena_value_type zero { 0, 0 };

    // go through the tiles
    for (auto tid = 0; tid < tiles; ++tid) {
        // form the beginning of this tile
        auto tileOrigin = arenaOrigin + tid * ofTile;

        // make a shape that excludes the last column of this tile
        auto shrinkHorz = tileShape + colRake;
        // combine with the tile origin to make the range
        auto hbox = arenaLayout.box(tileOrigin, shrinkHorz);
        // compute the horizontal phase
        auto phaseHorz = std::accumulate(hbox.begin(), hbox.end(), zero, phaseHorzAccum);
        // convert to an angle
        auto phiH = std::abs(phaseHorz) > eps ? std::atan2(phaseHorz.imag(), phaseHorz.real()) : 0;

        // make a shape that excludes the last row of this tile
        auto shrinkVert = tileShape + rowRake;
        // combine with the tile shape to make a range
        auto vbox = arenaLayout.box(tileOrigin, shrinkVert);
        // compute the vertical phase
        auto phaseVert = std::accumulate(vbox.begin(), vbox.end(), zero, phaseVertAccum);
        // convert to an angle
        auto phiV = std::abs(phaseVert) > eps ? std::atan2(phaseVert.imag(), phaseVert.real()) : 0;

        // fold the accumulated phases back into the data; careful to cover the entire tile
        // make a box that will generate *indices* from the tile layout
        auto idxBox = arenaLayout.box(tileOrigin, tileShape);
        // make a box with access to the *values* from the same layout
        auto valBox = arena.box(tileOrigin, tileShape);

        // use this deramper
        auto deramp =
            [&arena, &phiH, &phiV](carena_index_const_reference idx) -> carena_value_type {
                // unpack the index; ignore the tile id
                auto [_, i, j] = idx;
                // combine the two phases
                auto comb = i*phiV + j*phiH;
                // form the phase factor
                carena_value_type phase { std::cos(comb), std::sin(comb) };
                // look up pixel at {idx} and multiply it by this phase
                return arena[idx] * phase;
            };
        // to adjust the phase of every cell in the tile
        std::transform(idxBox.begin(), idxBox.end(), valBox.begin(), deramp);
    }

    // flush
    channel << pyre::journal::endl(__HERE__);
    // all done
    return;
}


// refine
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_refine(carena_reference arena, int refineFactor) -> void
{
    // make a channel
    pyre::journal::info_t channel("ampcor.sequential.refine");

    // get the layout of the arean
    auto layout = arena.layout();
    // and its shape
    auto shape = layout.shape();

    // we will carry out as many DFTs as there are pairs in the plan
    auto pairs = shape[0];
    // the refined ranks are in the arena shape
    int refinedRanks[] = { shape[1], shape[2] };
    // the dimensions of the unrefined tiles must be scaled down
    int unrefinedRanks[] = { shape[1] / refineFactor, shape[2] / refineFactor };
    // the distance between blocks is the number of cells in a tile
    auto distance = shape[1] * shape[2];
    // treat my storage area as an {fftw_complex} pointer; access to the raw pointer of the
    // arena storage strategy is a bit awkward; will rethink...
    fftwf_complex * data = reinterpret_cast<fftwf_complex *>(arena.data()->data());

    // forward DFT
    channel
        << "[" << _rank << "]: "
        << "        forward FFTs"
        << pyre::journal::endl(__HERE__);
    // make a plan
    auto forwardPlan = fftwf_plan_many_dft(2,                    // 2d- transform
                                           unrefinedRanks,       // the shape of the tiles
                                           pairs,                // this many DFTs
                                           // input
                                           data,                 // in-place
                                           refinedRanks,         // tiles are embedded
                                           1,                    // stride: densely packed
                                           distance,             // distance between tiles
                                           // output
                                           data,                 // in-place
                                           refinedRanks,         // tiles are embedded
                                           1,                    // stride: densely packed
                                           distance,             // distance between tiles
                                           FFTW_FORWARD,         // forward transform
                                           FFTW_ESTIMATE         // don't touch the input array
                                           );
    // if something went wrong
    if (forwardPlan == NULL) {
        // there isn't much I can do
        pyre::journal::error_t error("ampcor.sequential.refine");
        // so just complain
        error
            << "while planning a forward DFT" << pyre::journal::newline
            << "fftw returned " << forwardPlan << pyre::journal::newline
            << pyre::journal::endl(__HERE__);
        // and just in case the user has marked this error as non-fatal
        return;
    }
    // transform
    fftwf_execute(forwardPlan);

    // spread the spectrum: split the unrefined tile into four pieces and push them to the four
    // corners of the refined tile
    channel
        << "[" << _rank << "]: "
        << "        spreading the spectrum"
        << pyre::journal::endl(__HERE__);
    // do it
    _spreadSpectrum(arena, refineFactor);

    // reverse DFT
    channel
        << "[" << _rank << "]: "
        << "        reverse FFTs"
        << pyre::journal::endl(__HERE__);
    // make a plan
    auto reversePlan = fftwf_plan_many_dft(2,                    // 2d- transform
                                           refinedRanks,         // the shape of the tiles
                                           pairs,                // this many DFTs
                                           // input
                                           data,                 // in-place
                                           refinedRanks,         // whole tiles
                                           1,                    // stride: densely packed
                                           distance,             // distance between tiles
                                           // output
                                           data,                 // in-place
                                           refinedRanks,         // whole tiles
                                           1,                    // stride: densely packed
                                           distance,             // distance between tiles
                                           FFTW_BACKWARD,        // forward transform
                                           FFTW_ESTIMATE         // don't touch the input array
                                           );
    // if something went wrong
    if (reversePlan == NULL) {
        // there isn't much I can do
        pyre::journal::error_t error("ampcor.sequential.refine");
        // so just complain
        error
            << "while planning the reverse DFT" << pyre::journal::newline
            << "fftw returned " << forwardPlan << pyre::journal::newline
            << pyre::journal::endl(__HERE__);
        // and just in case the user has marked this error as non-fatal
        return;
    }
    // transform
    fftwf_execute(reversePlan);

    // flush
    channel << pyre::journal::endl(__HERE__);
    // all done
    return;
}


// spread the spectrum after a forward DFT
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_spreadSpectrum(carena_reference arena, int factor) -> void
{
    // this is the transformation we apply to each tile in the arena

    //     X X . .          X . . X
    //     X X . .          . . . .
    //     . . . .   --->   . . . .
    //     . . . .          X . . X

    // shown for factor=2

    // make a channel
    pyre::journal::info_t channel("ampcor.sequential.refine");

    // get the arena layout
    auto layout = arena.layout();
    // its shape
    auto shape = layout.shape();
    // and its origin
    auto origin = layout.origin();

    // form the shape of a tile block: this is the shape that has data before the spread
    arena_shape_type tile { shape[0], shape[1]/factor, shape[2]/factor };
    // form the shape of a tile quadrant; this is the shape of the blocks we will move around,
    // equivalent to a single "X" in the diagram above
    arena_shape_type quad{ shape[0], shape[1]/(2*factor), shape[2]/(2*factor) };

    // the origins of the three source quadrants: see the left block in the diagram above
    // the top right "X"
    arena_index_type s_01 {
        origin[0],                       // leave the tile id alone
        origin[1],                       // leave the row index alone
        origin[2] + quad[2]              // shift the column index one quadrant to the right
    };
    // the bottom left "X"
    arena_index_type s_10 {
        origin[0],                       // leave the tile id alone
        origin[1] + quad[1],             // shift the row index one quadrant downward
        origin[2]                        // leave the column index alone
    };
    // the bottom right "X"
    arena_index_type s_11 {
        origin[0],                       // leave the tile id alone
        origin[1] + quad[1],             // shift the row index one quadrant downward
        origin[2] + quad[2]              // shift the column index one quadrant to the right
    };

    // the origins of the three destination quadrants: see the right block in the diagram above
    // the top right "X"
    arena_index_type d_01 {
        s_01[0],                         // leave the tile id alone
        s_01[1],                         // leave the row index alone
        s_01[2] + (factor-1)*tile[2]     // shift the column index to the right
    };
    // the bottom left "X"
    arena_index_type d_10 {
        s_10[0],                         // leave the tile id alone
        s_10[1] + (factor-1)*tile[1],    // shift the row index downwards
        s_10[2]                          // leave the column index alone
    };
    // the bottom right "X"
    arena_index_type d_11 {
        s_11[0],                         // leave the tile id alone
        s_11[1] + (factor-1)*tile[1],    // shift the row index downwards
        s_11[2] + (factor-1)*tile[2]     // shift the column index to the right
    };

    // make the corresponding tiles
    // source
    auto src_01 = arena.box(s_01, quad);
    auto src_10 = arena.box(s_10, quad);
    auto src_11 = arena.box(s_11, quad);
    // destination
    auto dst_01 = arena.box(d_01, quad);
    auto dst_10 = arena.box(d_10, quad);
    auto dst_11 = arena.box(d_11, quad);

    // copy from {src} to {dst}
    std::copy(src_01.begin(), src_01.end(), dst_01.begin());
    std::copy(src_10.begin(), src_10.end(), dst_10.begin());
    std::copy(src_11.begin(), src_11.end(), dst_11.begin());

    // zero out the source quadrants
    // src_01
    for (auto & value : src_01) {
        value = 0;
    }
    // src_10
    for (auto & value : src_10) {
        value = 0;
    }
    // src_11
    for (auto & value : src_11) {
        value = 0;
    }

    // flush
    channel << pyre::journal::endl(__HERE__);
    // all done
    return;
}


// detect a complex arena
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_detectComplexArena(string_type name, carena_const_reference carena) -> arena_type
{
    // make a channel
    pyre::journal::info_t channel("ampcor.sequential.refine");

    // grab the layout of the complex arena
    auto layout = carena.layout();
    // use it to make a spec for the detected arena
    arena_spec spec { layout };
    // and with that the output data product
    arena_type arena { spec, name, spec.cells() };

    // detecting means
    auto detect = [](slc_pixel_type pixel) -> slc_value_type {
        // computing the amplitude of the complex pixel
        return std::abs(pixel);
    };

    // do it
    std::transform(carena.begin(), carena.end(), arena.begin(), detect);

    // flush
    channel << pyre::journal::endl(__HERE__);
    // all done
    return arena;
}


// zoom the correlation surface
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_zoom(const_arena_const_reference gamma) -> const_arena_type
{
    // make a channel
    pyre::journal::info_t channel("ampcor.sequential.zoom");

    // get the layout of the correlation surface
    auto layout = gamma.layout();
    // get its origin
    auto origin = layout.origin();
    // and its shape
    auto shape = layout.shape();

    // form the origin of the zoomed surface
    carena_index_type zoomedOrigin { origin[0], _zoomFactor*origin[1], _zoomFactor*origin[2] };
    // and the shape
    carena_shape_type zoomedShape { shape[0], _zoomFactor*shape[1], _zoomFactor*shape[2] };
    // use these to form a layout
    carena_layout_type zoomedLayout { zoomedShape, zoomedOrigin };
    // turn it into a spec
    carena_spec zoomedSpec { zoomedLayout };
    // and a product
    carena_type zoomedGamma { zoomedSpec, "zoomed_gamma_complex.dat", zoomedSpec.cells() };

    // show me
    channel
        << "[" << _rank << "]: "
        << "      zoomed gamma: origin (" << zoomedGamma.layout().origin()
        << ")+(" << zoomedGamma.layout().shape() << ")"
        << pyre::journal::endl(__HERE__);

    // make the source tile
    auto src = gamma.box(origin, shape);
    // and the destination tile
    auto dst = zoomedGamma.box(zoomedOrigin, shape);
    // transfer the data
    std::copy(src.begin(), src.end(), dst.begin());

    // refine in place
    _refine(zoomedGamma, _zoomFactor);

    // make a real gamma spec
    arena_spec realSpec { zoomedLayout };
    // and a product
    arena_type realGamma { realSpec, "zoomed_gamma.dat", realSpec.cells() };

    // transformation that just computes the magnitude
    auto detect = [](carena_value_type value) -> arena_value_type {
        // easy enough
        return std::abs(value);
    };

    // move the data
    std::transform(zoomedGamma.begin(), zoomedGamma.end(), realGamma.begin(), detect);

    // all dome; reopen as a {const} product
    return const_arena_type { realSpec, "zoomed_gamma.dat" };
}


# endif
