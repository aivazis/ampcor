// -*- c++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// parasim
// (c) 1998-2020 all rights reserved

// code guard
#if !defined(ampcor_correlators_Sequential_icc)
#error this file contains implementation details for ampcor::correlators::Sequential
#else


// metamethods
// constructor
template <class slcT, class offsetsT>
ampcor::correlators::Sequential<slcT, offsetsT>::
Sequential(int rank,
           slc_const_reference ref, slc_const_reference sec, offsets_reference map,
           slc_shape_const_reference refShape, slc_shape_const_reference secShape,
           int refineFactor, int refineMargin,
           int zoomFactor) :
    // my rank
    _rank { rank },
    // access to the input rasters
    _ref { ref },
    _sec { sec },
    _map { map },
    // the shapes of tiles
    _refShape { refShape },
    _secShape { secShape },
    // the correlation refinement parameters
    _refineFactor { refineFactor },
    _refineMargin { refineMargin },
    _zoomFactor { zoomFactor }
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.setup");
    // show me
    channel
        << "[" << _rank << "]: "
        << "new Sequential worker:" << pyre::journal::newline
        // the reference tile shape
        << "  reference tiles:" << pyre::journal::newline
        << "     shape: {" << _refShape << "}" << pyre::journal::newline
        // the secondary tile coarse arena
        << "  secondary tiles:" << pyre::journal::newline
        << "     shape: {" << _secShape << "}" << pyre::journal::newline
        // flush
        << pyre::journal::endl(__HERE__);

    // all done
    return;
}


// execute the correlation plan
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
adjust(offsets_layout_const_reference box)
{
    // make a channel
    pyre::journal::info_t channel("ampcor.sequential.adjust");

    // sign in
    channel
        << "[" << _rank << "]: "
        << "adjusting the offset map: origin: {"
        << box.origin() << "}, shape: {" << box.shape() << "}"
        << pyre::journal::endl(__HERE__);

    // step 1: initial exploration of the correlation surface
    channel
        << "[" << _rank << "]: "
        << "  initial exploration of the correlation surface:"
        << pyre::journal::endl(__HERE__);

    // validate the plan
    channel
        << "[" << _rank << "]: "
        << "    assembling and validating the execution plan"
        << pyre::journal::endl(__HERE__);
    // make a plan
    plan_type plan = _assemblePlan(box);

    // if there are no valid pairs
    if (plan.size() == 0) {
        // make a channel
        pyre::journal::error_t error("ampcor.sequential.adjust");
        // complain
        error
            << "all specified correlation pairs were invalid!"
            << pyre::journal::endl(__HERE__);
        // just in case the user has specified that errors aren't fatal
        return;
    }

    // make a coarse arena for the amplitudes of the reference tiles
    channel
        << "[" << _rank << "]: "
        << "    creating coarse arenas for the amplitudes"
        << pyre::journal::endl(__HERE__);
    // the reference tile arena has a trivial origin
    slc_index_type refOrigin {};
    // make the arena
    auto refCoarse = _createAmplitudeArena("coarse_ref.dat", plan.size(), _refShape, refOrigin);

    // the secondary tile arena has a non-trivial origin
    slc_index_type secOrigin = refOrigin - (_secShape - _refShape)/2;
    // make the arena
    auto secCoarse = _createAmplitudeArena("coarse_sec.dat", plan.size(), _secShape, secOrigin);

    // detect and transfer the reference tile tiles to the coarse arena
    channel
        << "[" << _rank << "]: "
        << "    detecting and transferring"
        << pyre::journal::endl(__HERE__);
    // move the data
    _detect(plan, refCoarse, secCoarse);

    // the reference tiles
    channel
        << "[" << _rank << "]: "
        << "    prepping the reference tiles:"
        << pyre::journal::endl(__HERE__);
    // adjust the reference tiles to zero mean and compute their variance
    channel
        << "[" << _rank << "]: "
        << "      adjusting the amplitudes to zero mean and computing statistics"
        << pyre::journal::endl(__HERE__);
    auto refVariances = _referenceStatistics(refCoarse);

    // next, the secondary tiles
    channel
        << "[" << _rank << "]: "
        << "    prepping the secondary tiles:"
        << pyre::journal::endl(__HERE__);

    // build sum area tables so we can do the same to the sliding window in the secondary tiles
    channel
        << "[" << _rank << "]: "
        << "      building sum area tables"
        << pyre::journal::endl(__HERE__);
    auto secSATs = _secondarySumAreaTables("coarse", secCoarse);

    // use the sum area tables to compute mean amplitude for all possible window placements
    channel
        << "[" << _rank << "]: "
        << "      computing statistics"
        << pyre::journal::endl(__HERE__);
    auto secMeans = _secondaryStatistics("coarse",
                                         refCoarse.layout(), secCoarse.layout(),
                                         secSATs);

    // generate the coarse correlation surface
    // slide {ref} sized chips around {sec} to compute the correlation hyper surface
    channel
        << "[" << _rank << "]: "
        << "    computing the correlation surface"
        << pyre::journal::endl(__HERE__);
    auto gamma = _correlate("coarse", refCoarse, refVariances, secCoarse, secMeans);

    // find its maxima
    channel
        << "[" << _rank << "]: "
        << "    locating the correlation surface maxima and recording the offsets"
        << pyre::journal::endl(__HERE__);
    _maxcor(plan, _map, gamma);

    // done with step 1
    channel
        << "[" << _rank << "]: "
        << "  done"
        << pyre::journal::endl(__HERE__);

    // step 2

    // all done
    return;
}


// implementation details
// plan assembly: pull out of {_map} the portion of the tile pairings that belong to me,
// discard the ones that don't fit within their respective inputs, and form the actual tile
// shapes
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_assemblePlan(offsets_layout_const_reference box) -> plan_type
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.adjust");

    // make a plan
    plan_type plan;

    // extent of the input rasters
    // the lower bound for an index into the reference raster is its origin
    auto refMinIndex = _ref.layout().origin();
    // similarly for the secondary raster
    auto secMinIndex = _sec.layout().origin();
    // form the strict upper bound of indices into the reference index
    auto refMaxIndex = refMinIndex + _ref.layout().shape();
    // ditto for the secondary raster
    auto secMaxIndex = secMinIndex + _sec.layout().shape();

    // shifts to apply to the tile centers to form the origins of tiles
    auto refShift = _refShape / 2;
    auto secShift = _secShape / 2;

    // go through my portion of the pairings
    for (auto pairIdx : _map.layout().box(box.origin(), box.shape())) {
        // get the pair
        auto pair = _map[pairIdx];
        // form the origin of the reference tile
        auto refOrigin = pair.ref - refShift;
        // if the reference origin is out of bounds
        if (refOrigin < refMinIndex) {
            // tell me
            channel
                << "[" << _rank << "]: "
                << "      pair (" << pairIdx << ") is invalid:"
                << pyre::journal::newline
                << "        origin: (" << refOrigin << ") < (" << refMinIndex << ")"
                << pyre::journal::newline;
            // skip this pairing; it is invalid
            continue;
        }
        // if the extent spills out of the reference raster
        if (refOrigin + _refShape > refMaxIndex) {
            // skip this pairing; it is invalid
            continue;
        }

        // form the origin of the secondary tile
        auto secOrigin = pair.ref + pair.shift - secShift;
        // if it's out of bounds
        if (secOrigin < secMinIndex) {
            // skip this pairing; it is invalid
            continue;
        }
        // if the extent spills out of the secondary raster
        if (secOrigin + _secShape > secMaxIndex) {
            // skip this pairing; it is invalid
            continue;
        }

        // we have a valid pair; turn it into a plan record
        plan.push_back({pairIdx, refOrigin, secOrigin});
    }

    // tell me
    channel
        << "[" << _rank << "]: "
        << "      " << plan.size() << "/" << box.cells() << " valid tile pairs"
        << pyre::journal::endl(__HERE__);

    // all done
    return plan;
}


template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_createAmplitudeArena(string_type name, int pairs,
                      slc_shape_const_reference tileShape,
                      slc_index_const_reference tileOrigin)
    -> arena_type
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.adjust");

    // turn the number of pairs into a shape
    typename arena_type::spec_type::id_layout_type::shape_type pairsShape { pairs };
    // combine with the tile shape to form the arena layout
    auto arenaShape = pairsShape * tileShape;

    // pair numbering starts at zero
    typename arena_type::spec_type::id_layout_type::index_type pairsOrigin { 0 };
    // combine with the tile origin to form the arena origin
    auto arenaOrigin = pairsOrigin * tileOrigin;

    // convert all this to a layout
    typename arena_type::layout_type arenaLayout { arenaShape, arenaOrigin };

    // show me
    channel
        << "[" << _rank << "]: "
        << "      creating '" << name << "':"
        << " origin=(" << arenaOrigin << "), shape=(" << arenaShape << ")"
        << pyre::journal::endl(__HERE__);

    // create the product and return it
    return arena_type(arenaLayout, name, arenaLayout.cells());
}


template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_detect(plan_const_reference plan, arena_reference refArena, arena_reference secArena) -> void
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.adjust");

    // detecting means
    auto detect = [](slc_pixel_type pixel) -> slc_value_type {
        // computing the amplitude of the complex pixel
        return std::abs(pixel);
    };

    // go through the plan
    for (auto pid = 0; pid < plan.size(); ++pid) {
        // get the origins of the tiles in their respective rasters
        const auto & [_, refOrigin, secOrigin] = plan[pid];
        // show me
        channel
            << "[" << _rank << "]: "
            << "      detecting ref(" << refOrigin << ") and sec(" << secOrigin <<  ")"
            << pyre::journal::endl(__HERE__);

        // we traverse one tile at a time
        typename arena_type::spec_type::id_layout_type::index_type pairShape { 1 };
        // the pairing id determines the shift from the arena origin to our tile
        arena_index_type pairShift { pid, 0, 0 };

        // specify the source tile in the reference raster
        auto refTile = _ref.box(refOrigin, _refShape);
        // specify the destination tile
        auto refArenaTile = refArena.box(refArena.layout().origin() + pairShift,
                                         pairShape * _refShape);
        // detect
        std::transform(refTile.begin(), refTile.end(), refArenaTile.begin(), detect);

        // specify the source tile in the secondary raster
        auto secTile = _sec.box(secOrigin, _secShape);
        // specify the destination tile
        auto secArenaTile = secArena.box(secArena.layout().origin() + pairShift,
                                         pairShape * _secShape);
        // detect
        std::transform(secTile.begin(), secTile.end(), secArenaTile.begin(), detect);
    }

    // all done
    return;
}


// reduce the tiles in {arena} to zero mean and compute their variances
// invoked only for reference tiles; the mean value of secondary tiles is a bit more
// complicated since it involves all possible placements of reference chips within their bounds
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_referenceStatistics(arena_reference arena) -> vector_pointer
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.ref.stats");

    // the shape of the arena contains the shape of its tiles
    const auto & shape = arena.layout().shape();
    // the origin of the arena contains the origin of its tiles
    const auto & origin = arena.layout().origin();

    // the number of pairs in the plan
    auto pairs = shape[0];

    // allocate storage for the variances
    auto variance = new vector_type(pairs);

    // go through each tile
    for (auto tid = 0; tid < pairs; ++tid) {
        // isolate the tile
        channel << "tile " << tid << pyre::journal::newline;
        // the origin of the tile
        arena_index_type tileOrigin { tid, origin[1], origin[2] };
        // the shape of the tile
        arena_shape_type tileShape { 1, shape[1], shape[2] };
        // make the tile
        auto tile = arena.box(tileOrigin, tileShape);

        // compute the sum of its elements
        auto sum = std::accumulate(tile.begin(), tile.end(), 0.0);
        channel << "  sum: " << sum << pyre::journal::newline;
        // compute the mean
        auto mean = sum / tile.layout().cells();
        channel << "  mean: " << mean << pyre::journal::newline;

        // subtract it from all elements and store
        std::transform(tile.begin(), tile.end(), tile.begin(),
                       [mean](arena_value_type in) -> arena_value_type {
                           return in - mean;
                       });

        // the accumulator of square
        auto sumsq = [](arena_value_type partial, arena_value_type in) {
            // easy enough
            return partial + in*in;
        };
        // compute the sum of the squares of all new elements
        auto var2 = std::accumulate(tile.begin(), tile.end(), 0.0, sumsq);
        channel << "  sum of squares: " << var2 << pyre::journal::newline;
        // compute the variance
        auto var = std::sqrt(var2);
        channel << "  variance: " << var << pyre::journal::newline;

        (*variance)[tid] = var;
    }

    // flush
    channel << pyre::journal::endl(__HERE__);

    // return the variances
    return vector_pointer(variance);
}


// build an arena of SATs for all secondary tiles
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_secondarySumAreaTables(string_type tag, arena_reference arena) -> const_arena_type
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.sat");

    // build the name of the product
    auto satName = tag + "_sat.dat";

    // get the arena layout
    const auto & arenaLayout = arena.layout();
    // the shape of the arena contains the shape of its tiles
    const auto & arenaShape = arenaLayout.shape();
    // the origin of the arena contains the origin of its tiles
    const auto & arenaOrigin = arenaLayout.origin();

    // the SAT has a border of zeroes as the leftmost column and topmost row
    // so the origin is up and to the left relative to the arena tiles
    arena_index_type satOrigin { arenaOrigin[0], arenaOrigin[1]-1, arenaOrigin[2]-1 };
    // and the shape is one longer within each tile
    arena_shape_type satShape { arenaShape[0], arenaShape[1]+1, arenaShape[2]+1 };
    // put them together to form the layout
    arena_layout_type satLayout { satShape, satOrigin };
    // and the spec
    arena_spec satSpec { satLayout };
    // and make the SAT; memory mapped grids are zero initialized automatically, so don't
    // forget to initialize the left column and top row if the grid storage strategy changes
    arena_type sat(satSpec, satName, satLayout.cells());

    // index shifts
    arena_index_type up { 0, -1, 0 };
    arena_index_type left { 0, 0, -1 };

    // visit the interior of the SAT
    for (auto idx : arenaLayout) {
        // this is the general form
        sat[idx] = arena[idx] + sat[idx+up] + sat[idx+left] - sat[idx+up+left];
        // show me
        channel
            << "sat[" << idx << "]"
            << pyre::journal::newline
            // the accesses
            << "    = "
            << "arena[" << idx << "]"
            << " + sat[" << idx+up << "]"
            << " + sat[" << idx+left << "]"
            << " - sat[" << idx+up+left << "]"
            << pyre::journal::newline
            // the values
            << "    = "
            << arena[idx]
            << " + " << sat[idx+up]
            << " + " << sat[idx+left]
            << " - " << sat[idx+up+left]
            << pyre::journal::newline
            // the answer
            << "    = " << sat[idx]
            << pyre::journal::newline;
    }
    // flush
    channel << pyre::journal::endl(__HERE__);

    // all done; reopen the product in read-only mode and hand it off
    return const_arena_type(satSpec, satName);;
}


// construct an arena that contains the average value of the elements of all {ref} sized chips
// placed with the {sec} tiles
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_secondaryStatistics(string_type tag,
                     arena_layout_const_reference refLayout,
                     arena_layout_const_reference secLayout,
                     const_arena_const_reference sat) -> const_arena_type
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.sec.stats");

    // build the name of the product
    auto meanName = tag + "_mean.dat";

    // get the shape of the reference arena
    auto refShape = refLayout.shape();
    // and the shape of the secondary arena
    auto secShape = secLayout.shape();
    // we also need the origin of the secondary arena
    auto secOrigin = secLayout.origin();

    // the number of pairs in the plan
    auto pairs = secLayout.shape()[0];

    // build the shape of the arena of mean values
    arena_shape_type meanShape { pairs, secShape[1]-refShape[1]+1, secShape[2]-refShape[2]+1 };
    // use it to make a layout
    arena_layout_type meanLayout { meanShape, secOrigin };
    // and with it a product spec
    arena_spec meanSpec { meanLayout };

    // show me
    channel
        << "arena of mean values: "
        << pyre::journal::newline
        // the origin
        << "  origin: (" << secOrigin << ")"
        << pyre::journal::newline
        // the shape
        << "  shape: (" << meanShape << ")"
        << ", " << meanSpec.cells() << " cells (" << meanSpec.bytes() << " bytes)"
        << pyre::journal::newline;

    // create the product
    arena_type mean { meanSpec, meanName, meanSpec.cells() };

    // ask the reference tile for its number of cells; don't forget that {refShape} knows how
    // many tiles are in the arena, so that has to be divided away
    auto refCells = refShape.cells() / pairs;
    // project the shape of the reference tile along each tile axis
    arena_index_type shapeS { 0, refShape[1], 0 };
    arena_index_type shapeE { 0, 0, refShape[2] };
    // useful shifts
    arena_index_type dNW { 0, -1, -1 };
    auto dNE = dNW + shapeE;
    auto dSW = dNW + shapeS;
    auto dSE = dNW + shapeE + shapeS;

    // go through all placements
    for (auto idx : meanLayout) {
        // compute the sum of the elements of this placement
        auto sum = sat[idx+dSE] - sat[idx+dSW] - sat[idx+dNE] + sat[idx+dNW];
        // form the mean and store it
        mean[idx] = sum / refCells;
        // show me
        channel
            << "mean[" << idx << "] = " << sum << " / " << refCells
            << " = " << mean[idx]
            << pyre::journal::newline;
    }

    // flush
    channel << pyre::journal::endl(__HERE__);

    // all done: reopen the product as read-only and return it
    return const_arena_type(meanSpec, meanName);
}


// compute the correlation surface
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_correlate(string_type tag,
           const_arena_const_reference ref,
           vector_pointer refStats,
           const_arena_const_reference sec,
           const_arena_const_reference secStats
           ) -> const_arena_type
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.gamma");

    // constants
    // prime the initializer
    const arena_value_type zero = 0;
    // a small number
    const auto epsilon = std::numeric_limits<arena_value_type>::epsilon();

    // get the shape of the reference arena
    auto refShape = ref.layout().shape();
    // and its origin
    auto refOrigin = ref.layout().origin();

    // build the name of the product
    auto gammaName = tag + "_gamma.dat";
    // the correlation surface looks just like the arena with the means of all the tile
    // placements
    arena_spec gammaSpec { secStats.layout() } ;

    // create the product
    arena_type gamma { gammaSpec, gammaName, gammaSpec.cells() };

    // the shape of the reference tiles fixes the correlation region for both reference and
    // secondary tiles
    arena_shape_type shape { 1, refShape[1], refShape[2] };

    // go through all indices covered by the {gamma} layout
    for (auto idx : gamma.layout()) {
        // extract the pair id
        auto pid = idx[0];

        // build the {ref} tile origin
        arena_index_type refTileOrigin { pid, refOrigin[1], refOrigin[2] };
        // combine with the fixed shape to form the reference tile
        auto refTile = ref.box(refTileOrigin, shape);

        // the secondary tile is the same shape but its origin is wherever the current placement is
        auto secTile = sec.box(idx, shape);

        // get the precomputed mean value for this placement
        auto mean = secStats[idx];

        // initialize the numerator
        auto num = zero;
        // and the sum of the squares of the secondary elements
        auto var2 = zero;

        // compute the correlation numerator and the square of the variance of the secondary
        // chip
        for (auto [r,s] = std::make_pair(refTile.begin(), secTile.begin());
             r != refTile.end();
             ++r, ++s ) {
            // remove the mean from the secondary value
            auto adj = *s - mean;
            // accumulate into the numerator
            num += *r * adj;
            // and into the variance
            var2 += adj * adj;
        }

        // unpack the reference variance
        auto revVar = (*refStats)[pid];
        // compute the secondary variance
        auto secVar = std::sqrt(var2);
        // check whether the numerator is viable
        if (std::abs(num) > epsilon) {
            // compute and save
            gamma[idx] = num / revVar / secVar;
        } else {
            // otherwise, store a zeor
            gamma[idx] = zero;
        }

        // show me
        channel
            << "ref: origin: (" << refOrigin << "), shape: (" << shape << ")"
            << pyre::journal::newline
            << "sec: origin: (" << idx
            << "), shape: (" << shape << "), "
            << "mean[" << idx << "] = " << mean
            << pyre::journal::newline
            << "gamma[" << idx << "]"
            << "  = ref[" << refTileOrigin << "] * sec[" << idx << "]"
            << pyre::journal::newline
            << "  = " << num << " / " << revVar << " / " << secVar
            << pyre::journal::newline
            << "  = " << gamma[idx]
            << pyre::journal::newline;
    }

    // flush
    channel << pyre::journal::endl(__HERE__);

    // all done: reopen the product as read-only and return it
    return const_arena_type(gammaSpec, gammaName);
}


// compute and store the locations of the maxima of the correlation surface
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_maxcor(plan_const_reference plan, offsets_reference map, const_arena_const_reference gamma)
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.maxcor");

    // get the layout of the correlation matrix
    const auto & corLayout = gamma.layout();
    // get the shape of the correlation matrix
    const auto & corShape = corLayout.shape();
    // and its origin
    const auto & corOrigin = corLayout.origin();

    // go through the plan
    for (auto pid = 0; pid < plan.size(); ++pid) {
        // narrow {gamma} to a tile corresponding to this pairing only
        // the shape
        arena_shape_type shape  { 1, corShape[1], corShape[2] };
        // the origin
        arena_index_type origin { pid, corOrigin[1], corOrigin[2] };
        // make the tile
        auto tile = corLayout.box(origin, shape);

        // initialize the correlation target
        float corMax = 0;
        // and a shift
        slc_index_type delta { 0,0 };

        // go through the tile
        for (auto idx : tile) {
            // get the correlation value
            auto cor = gamma[idx];
            // if it is greater than what we have seen before
            if (cor > corMax) {
                // save the new value
                corMax = cor;
                // form the associated shift
                delta = slc_index_type(idx[1], idx[2]);
            }
        }

        // get the corresponding record from the output product, in write enabled mode
        auto & rec = map[pid];
        // record the new value
        rec.gamma = corMax;
        // update the shift
        rec.shift = rec.shift + delta;
        // mark it as a good one
        rec.confidence = 1;
        // show me
        channel
            << pid << ": "
            << "(" << rec.ref << ") --> (" << rec.ref + rec.shift << "), "
            << "gamma: " << rec.gamma
            << pyre::journal::newline;
    }

    // flush
    channel << pyre::journal::endl(__HERE__);

    // all done
    return;
}


# endif

// end of file
