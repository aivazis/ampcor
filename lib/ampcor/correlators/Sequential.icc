// -*- c++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// parasim
// (c) 1998-2020 all rights reserved

// code guard
#if !defined(ampcor_correlators_Sequential_icc)
#error this file contains implementation details for ampcor::correlators::Sequential
#else


// metamethods
// destructor
template <class slcT, class offsetsT>
ampcor::correlators::Sequential<slcT, offsetsT>::
~Sequential()
{
    // clean up
    delete [] _pids;
}


// constructor
template <class slcT, class offsetsT>
ampcor::correlators::Sequential<slcT, offsetsT>::
Sequential(
           arena_layout_const_reference refLayout, arena_layout_const_reference secLayout,
           int refineFactor, int refineMargin,
           int zoomFactor) :
    // workload
    _pairs{ std::min(refLayout.shape()[0], secLayout.shape()[0]) },
    // the correlation refinement parameters
    _refineFactor{ refineFactor },
    _refineMargin{ refineMargin },
    _zoomFactor{ zoomFactor },
    // scratch space
    _pids{ new int [_pairs] },
    _refCoarse{ refLayout, "coarse_ref.dat", refLayout.cells() },
    _secCoarse{ secLayout, "coarse_sec.dat", secLayout.cells() }
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.setup");
    // show me
    channel
        << "new Sequential worker:" << pyre::journal::newline
        // number ofpairs
        << "  pairs: " << _pairs << pyre::journal::newline
        // the reference tile coarse arena
        << "  reference coarse arena:" << pyre::journal::newline
        << "    origin: {" << refLayout.origin() << "}" << pyre::journal::newline
        << "     shape: {" << refLayout.shape() << "}" << pyre::journal::newline
        << "     cells: " << refLayout.cells() << pyre::journal::newline
        // the secondary tile coarse arena
        << "  secondary coarse arena:" << pyre::journal::newline
        << "    origin: {" << secLayout.origin() << "}" << pyre::journal::newline
        << "     shape: {" << secLayout.shape() << "}" << pyre::journal::newline
        << "     cells: " << secLayout.cells() << pyre::journal::newline
        // flush
        << pyre::journal::endl(__HERE__);

    // all done
    return;
}


// accessors
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
pairs() const -> int
{
    // easy enough
    return _pairs;
}


// add a tile pair to the pile
template <class slcT, class offsetsT>
void
ampcor::correlators::Sequential<slcT, offsetsT>::
addTilePair(int tid, int pid, slc_const_reference ref, slc_const_reference sec)
{
    // verify that the tile id is within bounds
    if (tid >= _pairs) {
        // and if not, we have a bug
        pyre::journal::firewall_t channel("ampcor.sequential.transfer");
        // build a report and complain
        channel
            << "while adding tile pairs to the coarse arena:"
            << pyre::journal::newline
            << "tile id is out of bounds: "
            << pyre::journal::newline
            << "expected a number in [0," << _pairs << ")"
            << ", got "  << tid
            << pyre::journal::endl(__HERE__);
        // UNREACHABLE
        // unless the user has explicitly prevented firewalls from being fatal
    }

    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.transfer");

    // record the original collation order
    _pids[tid] = pid;

    // build the lambda that does the detection
    auto detect = [](slc_pixel_type cell) -> slc_value_type {
        // compute the magnitude and return
        return std::abs(cell);
    };

    // build the tile selector
    arena_index_type delta { tid, 0, 0 };

    // get the reference arena origin
    auto refArenaOrigin = _refCoarse.layout().origin();
    // build the destination index for this tile
    auto refTileOrigin = refArenaOrigin + delta;
    // get the reference arena shape
    auto refArenaShape = _refCoarse.layout().shape();
    // narrow the shape down to a single reference tile
    arena_shape_type refTileShape { 1, refArenaShape[1], refArenaShape[2] };
    // build the box that contains this reference tile
    auto refBox = _refCoarse.box(refTileOrigin, refTileShape);
    // move the data and detect in transit
    std::transform(ref.begin(), ref.end(), refBox.begin(), detect);

    // get the secondary arena origin
    auto secArenaOrigin = _secCoarse.layout().origin();
    // build the destination index for this tile
    auto secTileOrigin = secArenaOrigin + delta;
    // get the secondary arena shape
    auto secArenaShape = _secCoarse.layout().shape();
    // narrow the shape down to a single secondary tile
    arena_shape_type secTileShape { 1, secArenaShape[1], secArenaShape[2] };
    // build the box that contains this secondary tile
    auto secBox = _secCoarse.box(secTileOrigin, secTileShape);
    // move the data and detect in transit
    std::transform(sec.begin(), sec.end(), secBox.begin(), detect);

    // sign on
    channel
        << "added tile pair #" << tid << " (" << pid << ") to the arena"
        << pyre::journal::newline
        // reference tile info
        << "reference:"
        << pyre::journal::newline
        << "    from: (" << ref.layout().origin() << "), shape: (" << ref.layout().shape() << ")"
        << pyre::journal::newline
        << "      to: (" << refBox.layout().origin() << "), shape: " << refBox.layout().shape()
        << pyre::journal::newline
        // secondary tile info
        << "secondary:"
        << pyre::journal::newline
        << "    from: (" << sec.layout().origin() << "), shape: " << sec.layout().shape()
        << pyre::journal::newline
        << "      to: (" << secBox.layout().origin() << "), shape: " << secBox.layout().shape()
        << pyre::journal::newline
        // flush
        << pyre::journal::endl;

    // all done
    return;
}


// execute the correlation plan
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
adjust(offsets_reference map)
{
    // make a channel
    pyre::journal::info_t channel("ampcor.sequential.adjust");
    channel << "  adjusting the offset map" << pyre::journal::endl(__HERE__);

    // step 1: initial exploration of the correlation surface
    // adjust the reference tiles to zero mean and compute their variance
    channel << "    computing reference statistics" << pyre::journal::endl(__HERE__);
    auto refVariances = _referenceStatistics(_refCoarse);
    // build sum area tables so we can do the same to the sliding window in the secondary tiles
    channel << "    building SATs for the secondary tiles" << pyre::journal::endl(__HERE__);
    auto secSATs = _secondarySumAreaTables("coarse", _secCoarse);
    // use the sum area tables to compute mean amplitude for all possible window placements
    channel << "    computing secondary statistics" << pyre::journal::endl(__HERE__);
    auto secMeans = _secondaryStatistics("coarse",
                                         _refCoarse.layout(), _secCoarse.layout(),
                                         secSATs);
    // compute the correlation hyper surface
    channel << "    computing the correlation surface" << pyre::journal::endl(__HERE__);
    auto gamma = _correlate("coarse", _refCoarse, refVariances, _secCoarse, secMeans);
    // find its maxima
    channel << "    locating the correlation surface maxima" << pyre::journal::endl(__HERE__);
    _maxcor(gamma, map);

    // finish
    channel << "    done" << pyre::journal::endl(__HERE__);
    // all done
    return;
}


// implementation details
// reduce the tiles in {arena} to zero mean and compute their variances
// invoked only for reference tiles; the mean value of secondary tiles is a bit more
// complicated since it involves all possible placements of reference chips within their bounds
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_referenceStatistics(arena_reference arena) -> vector_pointer
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.ref.stats");

    // allocate storage for the variances
    auto variance = new vector_type(_pairs);

    // the shape of the arena contains the shape of its tiles
    const auto & shape = arena.layout().shape();
    // the origin of the arena contains the origin of its tiles
    const auto & origin = arena.layout().origin();

    // go through each tile
    for (auto tid = 0; tid < _pairs; ++tid) {
        // isolate the tile
        channel << "tile " << tid << pyre::journal::newline;
        // the origin of the tile
        arena_index_type tileOrigin { tid, origin[1], origin[2] };
        // the shape of the tile
        arena_shape_type tileShape { 1, shape[1], shape[2] };
        // make the tile
        auto tile = arena.box(tileOrigin, tileShape);

        // compute the sum of its elements
        auto sum = std::accumulate(tile.begin(), tile.end(), 0.0);
        channel << "  sum: " << sum << pyre::journal::newline;
        // compute the mean
        auto mean = sum / tile.layout().cells();
        channel << "  mean: " << mean << pyre::journal::newline;

        // subtract it from all elements and store
        std::transform(tile.begin(), tile.end(), tile.begin(),
                       [mean](arena_value_type in) -> arena_value_type {
                           return in - mean;
                       });

        // the accumulator of square
        auto sumsq = [](arena_value_type partial, arena_value_type in) {
            // easy enough
            return partial + in*in;
        };
        // compute the sum of the squares of all new elements
        auto var2 = std::accumulate(tile.begin(), tile.end(), 0.0, sumsq);
        channel << "  sum of squares: " << var2 << pyre::journal::newline;
        // compute the variance
        auto var = std::sqrt(var2);
        channel << "  variance: " << var << pyre::journal::newline;

        (*variance)[tid] = var;
    }

    // flush
    channel << pyre::journal::endl(__HERE__);

    // return the variances
    return vector_pointer(variance);
}


// build an arena of SATs for all secondary tiles
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_secondarySumAreaTables(string_type tag, arena_reference arena) -> const_arena_type
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.sat");

    // build the name of the product
    auto satName = tag + "_sat.dat";

    // get the arena layout
    const auto & arenaLayout = arena.layout();
    // the shape of the arena contains the shape of its tiles
    const auto & arenaShape = arenaLayout.shape();
    // the origin of the arena contains the origin of its tiles
    const auto & arenaOrigin = arenaLayout.origin();

    // the SAT has a border of zeroes as the leftmost column and topmost row
    // so the origin is up and to the left relative to the arena tiles
    arena_index_type satOrigin { arenaOrigin[0], arenaOrigin[1]-1, arenaOrigin[2]-1 };
    // and the shape is one longer within each tile
    arena_shape_type satShape { arenaShape[0], arenaShape[1]+1, arenaShape[2]+1 };
    // put them together to form the layout
    arena_layout_type satLayout { satShape, satOrigin };
    // and the spec
    arena_spec satSpec { satLayout };
    // and make the SAT; memory mapped grids are zero initialized automatically, so don't
    // forget to initialize the left column and top row if the grid storage strategy changes
    arena_type sat(satSpec, satName, satLayout.cells());

    // index shifts
    arena_index_type up { 0, -1, 0 };
    arena_index_type left { 0, 0, -1 };

    // visit the interior of the SAT
    for (auto idx : arenaLayout) {
        // this is the general form
        sat[idx] = arena[idx] + sat[idx+up] + sat[idx+left] - sat[idx+up+left];
        // show me
        channel
            << "sat[" << idx << "]"
            << pyre::journal::newline
            // the accesses
            << "    = "
            << "arena[" << idx << "]"
            << " + sat[" << idx+up << "]"
            << " + sat[" << idx+left << "]"
            << " - sat[" << idx+up+left << "]"
            << pyre::journal::newline
            // the values
            << "    = "
            << arena[idx]
            << " + " << sat[idx+up]
            << " + " << sat[idx+left]
            << " - " << sat[idx+up+left]
            << pyre::journal::newline
            // the answer
            << "    = " << sat[idx]
            << pyre::journal::newline;
    }
    // flush
    channel << pyre::journal::endl(__HERE__);

    // all done; reopen the product in read-only mode and hand it off
    return const_arena_type(satSpec, satName);;
}


// construct an arena that contains the average value of the elements of all {ref} sized chips
// placed with the {sec} tiles
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_secondaryStatistics(string_type tag,
                     arena_layout_const_reference refLayout,
                     arena_layout_const_reference secLayout,
                     const_arena_const_reference sat) -> const_arena_type
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.sec.stats");

    // build the name of the product
    auto meanName = tag + "_mean.dat";

    // get the shape of the reference arena
    auto refShape = refLayout.shape();
    // and the shape of the secondary arena
    auto secShape = secLayout.shape();
    // we also need the origin of the secondary arena
    auto secOrigin = secLayout.origin();

    // build the shape of the arena of mean values
    arena_shape_type meanShape { _pairs, secShape[1]-refShape[1]+1, secShape[2]-refShape[2]+1 };
    // use it to make a layout
    arena_layout_type meanLayout { meanShape, secOrigin };
    // and with it a product spec
    arena_spec meanSpec { meanLayout };

    // show me
    channel
        << "arena of mean values: "
        << pyre::journal::newline
        // the origin
        << "  origin: (" << secOrigin << ")"
        << pyre::journal::newline
        // the shape
        << "  shape: (" << meanShape << ")"
        << ", " << meanSpec.cells() << " cells (" << meanSpec.bytes() << " bytes)"
        << pyre::journal::newline;

    // create the product
    arena_type mean { meanSpec, meanName, meanSpec.cells() };

    // ask the reference tile for its number of cells; don't forget that {refShape} knows how
    // many tiles are in the arena, so that has to be divided away
    auto refCells = refShape.cells() / _pairs;
    // project the shape of the reference tile along each tile axis
    arena_index_type shapeS { 0, refShape[1], 0 };
    arena_index_type shapeE { 0, 0, refShape[2] };
    // useful shifts
    arena_index_type dNW { 0, -1, -1 };
    auto dNE = dNW + shapeE;
    auto dSW = dNW + shapeS;
    auto dSE = dNW + shapeE + shapeS;

    // go through all placements
    for (auto idx : meanLayout) {
        // compute the sum of the elements of this placement
        auto sum = sat[idx+dSE] - sat[idx+dSW] - sat[idx+dNE] + sat[idx+dNW];
        // form the mean and store it
        mean[idx] = sum / refCells;
        // show me
        channel
            << "mean[" << idx << "] = " << sum << " / " << refCells
            << " = " << mean[idx]
            << pyre::journal::newline;
    }

    // flush
    channel << pyre::journal::endl(__HERE__);

    // all done: reopen the product as read-only and return it
    return const_arena_type(meanSpec, meanName);
}


// compute the correlation surface
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_correlate(string_type tag,
           const_arena_const_reference ref,
           vector_pointer refStats,
           const_arena_const_reference sec,
           const_arena_const_reference secStats
           ) -> const_arena_type
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.gamma");

    // constants
    // prime the initializer
    const arena_value_type zero = 0;
    // a small number
    const auto epsilon = std::numeric_limits<arena_value_type>::epsilon();

    // get the shape of the reference arena
    auto refShape = ref.layout().shape();
    // and its origin
    auto refOrigin = ref.layout().origin();

    // build the name of the product
    auto gammaName = tag + "_gamma.dat";
    // the correlation surface looks just like the arena with the means of all the tile
    // placements
    arena_spec gammaSpec { secStats.layout() } ;

    // create the product
    arena_type gamma { gammaSpec, gammaName, gammaSpec.cells() };

    // the shape of the reference tiles fixes the correlation region for both reference and
    // secondary tiles
    arena_shape_type shape { 1, refShape[1], refShape[2] };

    // go through all indices covered by the {gamma} layout
    for (auto idx : gamma.layout()) {
        // extract the pair id
        auto pid = idx[0];

        // build the {ref} tile origin
        arena_index_type refTileOrigin { pid, refOrigin[1], refOrigin[2] };
        // combine with the fixed shape to form the reference tile
        auto refTile = ref.box(refTileOrigin, shape);

        // the secondary tile is the same shape but its origin is wherever the current placement is
        auto secTile = sec.box(idx, shape);

        // get the precomputed mean value for this placement
        auto mean = secStats[idx];

        // initialize the numerator
        auto num = zero;
        // and the sum of the squares of the secondary elements
        auto var2 = zero;

        // compute the correlation numerator and the square of the variance of the secondary
        // chip
        for (auto [r,s] = std::make_pair(refTile.begin(), secTile.begin());
             r != refTile.end();
             ++r, ++s ) {
            // remove the mean from the secondary value
            auto adj = *s - mean;
            // accumulate into the numerator
            num += *r * adj;
            // and into the variance
            var2 += adj * adj;
        }

        // unpack the reference variance
        auto revVar = (*refStats)[pid];
        // compute the secondary variance
        auto secVar = std::sqrt(var2);
        // check whether the numerator is viable
        if (std::abs(num) > epsilon) {
            // compute and save
            gamma[idx] = num / revVar / secVar;
        } else {
            // otherwise, store a zeor
            gamma[idx] = zero;
        }

        // show me
        channel
            << "ref: origin: (" << refOrigin << "), shape: (" << shape << ")"
            << pyre::journal::newline
            << "sec: origin: (" << idx
            << "), shape: (" << shape << "), "
            << "mean[" << idx << "] = " << mean
            << pyre::journal::newline
            << "gamma[" << idx << "]"
            << "  = ref[" << refTileOrigin << "] * sec[" << idx << "]"
            << pyre::journal::newline
            << "  = " << num << " / " << revVar << " / " << secVar
            << pyre::journal::newline
            << "  = " << gamma[idx]
            << pyre::journal::newline;
    }

    // flush
    channel << pyre::journal::endl(__HERE__);

    // all done: reopen the product as read-only and return it
    return const_arena_type(gammaSpec, gammaName);
}


// compute and store the locations of the maxima of the correlation surface
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
_maxcor(const_arena_const_reference gamma, offsets_reference map)
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.maxcor");

    // go through all the entries in the correlation surface
    for (auto idx : gamma.layout()) {

        // extract the id
        auto tid = idx[0];
        // map to the pair id
        auto pid = _pids[tid];
        // get the value of the correlation surface
        auto cor = gamma[idx];
        // get the pixel from the output
        auto & record = map[pid];

        // if this value is bigger than what's already there
        if (cor > record.gamma) {
            // record the new value
            record.gamma = cor;
            // the new shift
            record.shift = std::make_pair<float, float>(idx[1], idx[2]);
            // mark it as a good one
            record.confidence = 1;
        }

        // show mw
        channel
            << "cor[" << pid << "].gamma = " << record.gamma
            << pyre::journal::newline
            << "gamma[" << idx << "] = " << cor
            << pyre::journal::newline;
    }

    // flush
    channel << pyre::journal::endl(__HERE__);

    // all done
    return;
}


# endif

// end of file
