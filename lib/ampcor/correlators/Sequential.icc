// -*- c++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// parasim
// (c) 1998-2020 all rights reserved

// code guard
#if !defined(ampcor_correlators_Sequential_icc)
#error this file contains implementation details for ampcor::correlators::Sequential
#else


// metamethods
// destructor
template <class inputT, class outputT>
ampcor::correlators::Sequential<inputT, outputT>::
~Sequential()
{
    // clean up
    delete [] _refinedArena;
    delete [] _coarseArena;
    delete [] _pids;
}


// constructor
template <class inputT, class outputT>
ampcor::correlators::Sequential<inputT, outputT>::
Sequential(size_type pairs,
           layout_const_reference ref, layout_const_reference sec,
           size_type refineFactor, size_type refineMargin,
           size_type zoomFactor) :
    // workload
    _pairs{ pairs },
    // the correlation refinement parameters
    _refineFactor{ refineFactor },
    _refineMargin{ refineMargin },
    _zoomFactor{ zoomFactor },

    // the layout of things
    // initially
    _refLayout{ ref },
    _secLayout{ sec },
    _corLayout{ sec.shape() - ref.shape() + shape_type::fill(1) },
    // after refinement
    _refRefinedLayout{ refineFactor * ref.shape()},
    _secRefinedLayout{ refineFactor * (ref.shape() + shape_type::fill(2 * refineMargin))},
    _corRefinedLayout{ shape_type::fill(2 * refineFactor * refineMargin + 1) },
    // after zooming
    _corZoomedLayout{ zoomFactor * _corRefinedLayout.shape() },

    // the number of cells
    // initially
    _refCells{ ref.cells() },
    _secCells{ sec.cells() },
    _corCells{ _corLayout.cells() },
    // after refinement
    _refRefinedCells{ _refRefinedLayout.cells() },
    _secRefinedCells{ _secRefinedLayout.cells() },

    // strides
    _coarseStride{ _refCells + _secCells },
    _refinedStride{ _refRefinedCells + _secRefinedCells },

    // memory footprint, in bytes
    // initially
    _refBytes{ _refCells * sizeof(value_type) },
    _secBytes{ _secCells * sizeof(value_type) },
    _corBytes{ _corCells * sizeof(value_type) }, // the correlation matrix is real...
    // after refinement
    _refRefinedBytes{ _refRefinedCells * sizeof(value_type) },
    _secRefinedBytes{ _secRefinedCells * sizeof(value_type) },

    // scratch space capacity
    _coarseArenaCells { _pairs * _coarseStride },
    _refinedArenaCells { _pairs * _refinedStride },
    // scratch space memory footprint
    _coarseArenaBytes { _coarseArenaCells * sizeof(value_type) },
    _refinedArenaBytes { _refinedArenaCells * sizeof(value_type) },
    // scratch space
    _pids{ new size_type [_pairs] },
    _coarseArena{ new value_type [_coarseArenaCells] },
    _refinedArena{ new value_type [_refinedArenaCells] }
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.setup");
    // show me
    channel
        << pyre::journal::at(__HERE__)
        << "new Sequential worker:"
        << pyre::journal::newline
        << "  pairs: " << _pairs
        << pyre::journal::newline
        << "    ref shape: {" << _refLayout.shape() << "}, " << _refCells << " cells"
        << pyre::journal::newline
        << "    sec shape: {" << _secLayout.shape() << "}, " << _secCells << " cells"
        << pyre::journal::newline

        << "  arena: "
        << pyre::journal::newline
        << "    at: " << _coarseArena
        << pyre::journal::newline
        << "    footprint: " << _pairs*(_refCells + _secCells) << " cells in "
        << _coarseArenaBytes << " bytes"
        << pyre::journal::newline

        << "  refinement:"
        << pyre::journal::newline
        << "    factor: " << refineFactor
        << pyre::journal::newline
        << "    margin: " << refineMargin
        << pyre::journal::newline
        << "    refined ref shape: {" << _refRefinedLayout.shape()
        << "}, " << _refRefinedCells << " cells"
        << pyre::journal::newline
        << "    refined sec shape: {" << _secRefinedLayout.shape()
        << "}, " << _secRefinedCells << " cells"
        << pyre::journal::newline

        << "  refined arena: "
        << pyre::journal::newline
        << "    at: " << _refinedArena
        << pyre::journal::newline
        << "    footprint: " << _pairs*(_refRefinedCells + _secRefinedCells) << " cells in "
        << _refinedArenaBytes << " bytes"
        << pyre::journal::endl;
}


// accessors
template <class inputT, class outputT>
auto
ampcor::correlators::Sequential<inputT, outputT>::
pairs() const -> size_type
{
    // easy enough
    return _pairs;
}


template <class inputT, class outputT>
auto
ampcor::correlators::Sequential<inputT, outputT>::
coarseArena() const -> const_pointer
{
    // easy enough
    return _coarseArena;
}


template <class inputT, class outputT>
auto
ampcor::correlators::Sequential<inputT, outputT>::
coarseArenaCells() const -> size_type
{
    // easy enough
    return _coarseArenaCells;
}


template <class inputT, class outputT>
auto
ampcor::correlators::Sequential<inputT, outputT>::
coarseArenaBytes() const -> size_type
{
    // easy enough
    return _coarseArenaBytes;
}


template <class inputT, class outputT>
auto
ampcor::correlators::Sequential<inputT, outputT>::
coarseArenaStride() const -> size_type
{
    // easy enough
    return _coarseStride;
}


// interface
// zero out the coarse arena
template <class inputT, class outputT>
void
ampcor::correlators::Sequential<inputT, outputT>::
fillCoarseArena(value_type value) const
{
    // easy enough
    std::fill(_coarseArena, _coarseArena+_coarseArenaCells, value);
    // all done
    return;
}


// record the sequence number of this pairing in the original plan
template <class inputT, class outputT>
void
ampcor::correlators::Sequential<inputT, outputT>::
addPair(size_type tid, size_type pid)
{
    // easy enough
    _pids[tid] = pid;
    // all done
    return;
}


// add a reference tile to the coarse arena
template <class inputT, class outputT>
void
ampcor::correlators::Sequential<inputT, outputT>::
addReferenceTile(size_type tid, input_const_reference ref)
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.transfer");
    // sign on
    channel
        << "adding reference tile #" << tid << "(" << _pids[tid] << ")"
        << " to the arena"
        << pyre::journal::newline;

    // figure out the starting address of this tile in the arena given its pair id
    pointer support = _coarseArena + tid * _coarseStride;

    // the lambda that does the detection
    auto detect = [](cell_type cell) -> value_type {
                      // compute the magnitude and return
                      return std::abs(cell);
                  };
    // move the data and detect in transit
    std::transform(ref.begin(), ref.end(), support, detect);

    // tell me
    channel
        << "read+transformed+stored " << ref.cells() << " cells from (" << *ref.layout().begin()
        << ") into " << ref.bytes()/2 << " bytes at "<< support
        << pyre::journal::endl(__HERE__);

    // all done
    return;
}


// add a secondary tile to the coarse arena
template <class inputT, class outputT>
void
ampcor::correlators::Sequential<inputT, outputT>::
addSecondaryTile(size_type tid, input_const_reference sec)
{
    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.transfer");
    // sign on
    channel
        << "adding secondary tile #" << tid << "(" << _pids[tid] << ")"
        << " to the arena"
        << pyre::journal::newline;

    // figure out the starting address of this tile in the arena given its pair id
    pointer support = _coarseArena + tid * _coarseStride + _refCells;
    // the lambda that does the detection
    auto detect = [](cell_type cell) -> value_type {
                      // compute the magnitude and return
                      return std::abs(cell);
                  };
    // move the data and detect in transit
    std::transform(sec.begin(), sec.end(), support, detect);

    // tell me
    channel
        << "read+transformed+stored " << sec.cells() << " cells from (" << *sec.layout().begin()
        << ") into " << sec.bytes()/2 << " bytes at "<< support
        << pyre::journal::endl(__HERE__);

    // all done
    return;
}


// execute the correlation plan
template <class inputT, class outputT>
void
ampcor::correlators::Sequential<inputT, outputT>::
adjust(output_reference)
{
    // all done
    return;
}


# endif

// end of file
