// -*- c++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// parasim
// (c) 1998-2020 all rights reserved

// code guard
#if !defined(ampcor_correlators_Sequential_icc)
#error this file contains implementation details for ampcor::correlators::Sequential
#else


// metamethods
// destructor
template <class slcT, class offsetsT>
ampcor::correlators::Sequential<slcT, offsetsT>::
~Sequential()
{
    // clean up
    delete [] _pids;
}


// constructor
template <class slcT, class offsetsT>
ampcor::correlators::Sequential<slcT, offsetsT>::
Sequential(size_type pairs,
           arena_layout_const_reference ref, arena_layout_const_reference sec,
           size_type refineFactor, size_type refineMargin,
           size_type zoomFactor) :
    // workload
    _pairs{ pairs },
    // the correlation refinement parameters
    _refineFactor{ refineFactor },
    _refineMargin{ refineMargin },
    _zoomFactor{ zoomFactor },
    // scratch space
    _pids{ new size_type [_pairs] },
    _refCoarse{ ref, "coarse_ref.dat", ref.cells() },
    _secCoarse{ sec, "coarse_sec.dat", sec.cells() }
{
    // we have some invariants to check: the number of pairs must match the reference and
    // secondary grid layout
    if (_pairs != ref.shape()[0] or _pairs != sec.shape()[0]) {
        // we have a bug
        pyre::journal::firewall_t channel("ampcor.sequential.setup");
        // build a report and complain
        channel
            << "while instantiating the sequential worker:"
            << pyre::journal::newline
            << "mismatch in the tile pair counts:"
            << pyre::journal::newline
            << "expected: " << _pairs << " tile pairs"
            << ", got " << ref.shape()[0] << " reference tiles"
            << ", and " << sec.shape()[0] << " secondary tiles"
            << pyre::journal::endl(__HERE__);
        // UNREACHABLE
        // unless the user has explicitly prevented firewalls from being fatal
    }

    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.setup");
    // show me
    channel
        << "new Sequential worker:"
        << pyre::journal::newline
        << "  pairs: " << _pairs
        << pyre::journal::newline
        << "    ref shape: {" << ref.shape() << "}, " << ref.cells() << " cells"
        << pyre::journal::newline
        << "    sec shape: {" << sec.shape() << "}, " << sec.cells() << " cells"
        << pyre::journal::endl(__HERE__);

    // all done
    return;
}


// accessors
template <class slcT, class offsetsT>
auto
ampcor::correlators::Sequential<slcT, offsetsT>::
pairs() const -> size_type
{
    // easy enough
    return _pairs;
}


// add a tile pair to the pile
template <class slcT, class offsetsT>
void
ampcor::correlators::Sequential<slcT, offsetsT>::
addTilePair(size_type tid, size_type pid, slc_const_reference ref, slc_const_reference sec)
{
    // verify that the tile id is within bounds
    if (tid >= _pairs) {
        // and if not, we have a bug
        pyre::journal::firewall_t channel("ampcor.sequential.transfer");
        // build a report and complain
        channel
            << "while adding tile pairs to the coarse arena:"
            << pyre::journal::newline
            << "tile id is out of bounds: "
            << pyre::journal::newline
            << "expected a number in [0," << _pairs << ")"
            << ", got "  << tid
            << pyre::journal::endl(__HERE__);
        // UNREACHABLE
        // unless the user has explicitly prevented firewalls from being fatal
    }

    // record the original collation order
    _pids[tid] = pid;

    // build the lambda that does the detection
    auto detect = [](slc_pixel_type cell) -> slc_value_type {
                      // compute the magnitude and return
                      return std::abs(cell);
                  };
    // form the destination index; works for either tile grid
    arena_index_type origin { tid, 0, 0 };

    // use the shape of the reference tile
    const auto & refShape = ref.layout().shape();
    // to build the shape of the reference box
    arena_shape_type refBoxShape { 0, refShape[0], refShape[1] };
    // and the box itself
    auto refBox = _refCoarse.box(origin, refBoxShape);
    // move the data and detect in transit
    std::transform(ref.begin(), ref.end(), refBox.begin(), detect);

    // use the shape of the secondary tile
    const auto & secShape = sec.layout().shape();
    // to build the shape of the secondary box
    arena_shape_type secBoxShape { 0, secShape[0], secShape[1] };
    // and the box itself
    auto secBox = _secCoarse.box(origin, secBoxShape);
    // move the data and detect in transit
    std::transform(sec.begin(), sec.end(), secBox.begin(), detect);

    // make a channel
    pyre::journal::debug_t channel("ampcor.sequential.transfer");
    // sign on
    channel
        << "added tile pair #" << tid << " (" << pid << ") to the arena"
        << pyre::journal::newline
        // reference tile info
        << "reference:"
        << pyre::journal::newline
        << "    from: (" << ref.layout().origin() << "), shape: (" << ref.layout().shape() << ")"
        << pyre::journal::newline
        << "      to: (" << refBox.layout().origin() << "), shape: " << refBox.layout().shape()
        << pyre::journal::newline
        // secondary tile info
        << "secondary:"
        << pyre::journal::newline
        << "    from: (" << sec.layout().origin() << "), shape: " << sec.layout().shape()
        << pyre::journal::newline
        << "      to: (" << secBox.layout().origin() << "), shape: " << secBox.layout().shape()
        << pyre::journal::newline
        // flush
        << pyre::journal::endl;


    // all done
    return;
}


// execute the correlation plan
template <class slcT, class offsetsT>
void
ampcor::correlators::Sequential<slcT, offsetsT>::
adjust(offsets_reference map)
{
    // step 1: initial exploration of the correlation surface
    // adjust the reference tiles to zero mean and compute their variance
    // build sum area tables so we can do the same to the sliding window in the secondary tiles
    // use the sum area tables to compute mean amplitude for all possible window placements
    // compute the correlation hyper surface
    // find its maxima

    // all done
    return;
}


# endif

// end of file
